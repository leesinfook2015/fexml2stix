#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Tue Aug  4 15:52:40 2015 by generateDS.py version 2.16a.
#
# Command line options:
#   ('-f', '')
#   ('-o', 'fealerts.py')
#   ('-s', 'fesubclasses.py')
#   ('--super', 'fealerts')
#
# Command line arguments:
#   FireEyeAlertSchema.xsd
#
# Command line:
#   /home/user/Projects/MISP/fexml2stix/bin/generateDS.py -f -o "fealerts.py" -s "fesubclasses.py" --super="fealerts" FireEyeAlertSchema.xsd
#
# Current working directory (os.getcwd()):
#   fexml
#

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
from lxml import etree as etree_


Validate_simpletypes_ = True


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        parser = etree_.ETCompatXMLParser()
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:

    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (time_parts[0], micro_seconds, )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.  We should:
            # - AND the outer elements
            # - OR the inner elements
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    if re_.search(patterns2, target) is not None:
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace, pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace, name, pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name, base64.b64encode(self.value), self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class alerts(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, msg=None, product=None, version=None, appliance=None, appliance_id=None, alert=None):
        self.original_tagname_ = None
        self.msg = _cast(None, msg)
        self.product = _cast(None, product)
        self.version = _cast(None, version)
        self.appliance = _cast(None, appliance)
        self.appliance_id = _cast(None, appliance_id)
        if alert is None:
            self.alert = []
        else:
            self.alert = alert
    def factory(*args_, **kwargs_):
        if alerts.subclass:
            return alerts.subclass(*args_, **kwargs_)
        else:
            return alerts(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_alert(self): return self.alert
    def set_alert(self, alert): self.alert = alert
    def add_alert(self, value): self.alert.append(value)
    def insert_alert_at(self, index, value): self.alert.insert(index, value)
    def replace_alert_at(self, index, value): self.alert[index] = value
    def get_msg(self): return self.msg
    def set_msg(self, msg): self.msg = msg
    def get_product(self): return self.product
    def set_product(self, product): self.product = product
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_appliance(self): return self.appliance
    def set_appliance(self, appliance): self.appliance = appliance
    def get_appliance_id(self): return self.appliance_id
    def set_appliance_id(self, appliance_id): self.appliance_id = appliance_id
    def validate_ProductType(self, value):
        # Validate type ProductType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Web MPS', 'Email MPS', 'File MPS', 'MAS', 'CMS']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ProductType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.alert
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='alerts', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='alerts')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='alerts', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='alerts'):
        if self.msg is not None and 'msg' not in already_processed:
            already_processed.add('msg')
            outfile.write(' msg=%s' % (self.gds_format_string(quote_attrib(self.msg).encode(ExternalEncoding), input_name='msg'), ))
        if self.product is not None and 'product' not in already_processed:
            already_processed.add('product')
            outfile.write(' product=%s' % (quote_attrib(self.product), ))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (self.gds_format_string(quote_attrib(self.version).encode(ExternalEncoding), input_name='version'), ))
        if self.appliance is not None and 'appliance' not in already_processed:
            already_processed.add('appliance')
            outfile.write(' appliance=%s' % (self.gds_format_string(quote_attrib(self.appliance).encode(ExternalEncoding), input_name='appliance'), ))
        if self.appliance_id is not None and 'appliance_id' not in already_processed:
            already_processed.add('appliance_id')
            outfile.write(' appliance-id=%s' % (self.gds_format_string(quote_attrib(self.appliance_id).encode(ExternalEncoding), input_name='appliance-id'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='alerts', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for alert_ in self.alert:
            alert_.export(outfile, level, namespace_, name_='alert', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='alerts'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.msg is not None and 'msg' not in already_processed:
            already_processed.add('msg')
            showIndent(outfile, level)
            outfile.write('msg="%s",\n' % (self.msg,))
        if self.product is not None and 'product' not in already_processed:
            already_processed.add('product')
            showIndent(outfile, level)
            outfile.write('product="%s",\n' % (self.product,))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            showIndent(outfile, level)
            outfile.write('version="%s",\n' % (self.version,))
        if self.appliance is not None and 'appliance' not in already_processed:
            already_processed.add('appliance')
            showIndent(outfile, level)
            outfile.write('appliance="%s",\n' % (self.appliance,))
        if self.appliance_id is not None and 'appliance_id' not in already_processed:
            already_processed.add('appliance_id')
            showIndent(outfile, level)
            outfile.write('appliance_id="%s",\n' % (self.appliance_id,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('alert=[\n')
        level += 1
        for alert_ in self.alert:
            showIndent(outfile, level)
            outfile.write('model_.alert(\n')
            alert_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('msg', node)
        if value is not None and 'msg' not in already_processed:
            already_processed.add('msg')
            self.msg = value
        value = find_attr_value_('product', node)
        if value is not None and 'product' not in already_processed:
            already_processed.add('product')
            self.product = value
            self.validate_ProductType(self.product)    # validate type ProductType
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
        value = find_attr_value_('appliance', node)
        if value is not None and 'appliance' not in already_processed:
            already_processed.add('appliance')
            self.appliance = value
        value = find_attr_value_('appliance-id', node)
        if value is not None and 'appliance-id' not in already_processed:
            already_processed.add('appliance-id')
            self.appliance_id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'alert':
            obj_ = alert.factory()
            obj_.build(child_)
            self.alert.append(obj_)
            obj_.original_tagname_ = 'alert'
# end class alerts


class alert(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, product=None, severity=None, name=None, version=None, sensor=None, id=None, appliance_id=None, explanation=None, src=None, alert_url=None, action=None, locations=None, occurred=None, dst=None, smtp_message=None, interface=None):
        self.original_tagname_ = None
        self.product = _cast(None, product)
        self.severity = _cast(None, severity)
        self.name = _cast(None, name)
        self.version = _cast(None, version)
        self.sensor = _cast(None, sensor)
        self.id = _cast(int, id)
        self.appliance_id = _cast(None, appliance_id)
        self.explanation = explanation
        self.src = src
        self.alert_url = alert_url
        self.action = action
        self.locations = locations
        if isinstance(occurred, basestring):
            initvalue_ = datetime_.datetime.strptime(occurred, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = occurred
        self.occurred = initvalue_
        self.dst = dst
        self.smtp_message = smtp_message
        self.interface = interface
    def factory(*args_, **kwargs_):
        if alert.subclass:
            return alert.subclass(*args_, **kwargs_)
        else:
            return alert(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_explanation(self): return self.explanation
    def set_explanation(self, explanation): self.explanation = explanation
    def get_src(self): return self.src
    def set_src(self, src): self.src = src
    def get_alert_url(self): return self.alert_url
    def set_alert_url(self, alert_url): self.alert_url = alert_url
    def get_action(self): return self.action
    def set_action(self, action): self.action = action
    def get_locations(self): return self.locations
    def set_locations(self, locations): self.locations = locations
    def get_occurred(self): return self.occurred
    def set_occurred(self, occurred): self.occurred = occurred
    def get_dst(self): return self.dst
    def set_dst(self, dst): self.dst = dst
    def get_smtp_message(self): return self.smtp_message
    def set_smtp_message(self, smtp_message): self.smtp_message = smtp_message
    def get_interface(self): return self.interface
    def set_interface(self, interface): self.interface = interface
    def get_product(self): return self.product
    def set_product(self, product): self.product = product
    def get_severity(self): return self.severity
    def set_severity(self, severity): self.severity = severity
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_sensor(self): return self.sensor
    def set_sensor(self, sensor): self.sensor = sensor
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_appliance_id(self): return self.appliance_id
    def set_appliance_id(self, appliance_id): self.appliance_id = appliance_id
    def validate_feDateTime(self, value):
        # Validate type feDateTime, a restriction on xs:dateTime.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_ProductType(self, value):
        # Validate type ProductType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Web MPS', 'Email MPS', 'File MPS', 'MAS', 'CMS']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ProductType' % {"value" : value.encode("utf-8")} )
    def validate_AlertSeverity(self, value):
        # Validate type AlertSeverity, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['crit', 'majr', 'minr', 'unkn']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AlertSeverity' % {"value" : value.encode("utf-8")} )
    def validate_AlertType(self, value):
        # Validate type AlertType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['malware-callback', 'domain-match', 'infection-match', 'web-infection', 'malware-object', 'ips-event']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on AlertType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.explanation is not None or
            self.src is not None or
            self.alert_url is not None or
            self.action is not None or
            self.locations is not None or
            self.occurred is not None or
            self.dst is not None or
            self.smtp_message is not None or
            self.interface is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='alert', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='alert')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='alert', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='alert'):
        if self.product is not None and 'product' not in already_processed:
            already_processed.add('product')
            outfile.write(' product=%s' % (quote_attrib(self.product), ))
        if self.severity is not None and 'severity' not in already_processed:
            already_processed.add('severity')
            outfile.write(' severity=%s' % (quote_attrib(self.severity), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (quote_attrib(self.name), ))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (self.gds_format_string(quote_attrib(self.version).encode(ExternalEncoding), input_name='version'), ))
        if self.sensor is not None and 'sensor' not in already_processed:
            already_processed.add('sensor')
            outfile.write(' sensor=%s' % (self.gds_format_string(quote_attrib(self.sensor).encode(ExternalEncoding), input_name='sensor'), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id="%s"' % self.gds_format_integer(self.id, input_name='id'))
        if self.appliance_id is not None and 'appliance_id' not in already_processed:
            already_processed.add('appliance_id')
            outfile.write(' appliance-id=%s' % (self.gds_format_string(quote_attrib(self.appliance_id).encode(ExternalEncoding), input_name='appliance-id'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='alert', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.explanation is not None:
            self.explanation.export(outfile, level, namespace_, name_='explanation', pretty_print=pretty_print)
        if self.src is not None:
            self.src.export(outfile, level, namespace_, name_='src', pretty_print=pretty_print)
        if self.alert_url is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%salert-url>%s</%salert-url>%s' % (namespace_, self.gds_format_string(quote_xml(self.alert_url).encode(ExternalEncoding), input_name='alert-url'), namespace_, eol_))
        if self.action is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saction>%s</%saction>%s' % (namespace_, self.gds_format_string(quote_xml(self.action).encode(ExternalEncoding), input_name='action'), namespace_, eol_))
        if self.locations is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slocations>%s</%slocations>%s' % (namespace_, self.gds_format_string(quote_xml(self.locations).encode(ExternalEncoding), input_name='locations'), namespace_, eol_))
        if self.occurred is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soccurred>%s</%soccurred>%s' % (namespace_, self.gds_format_datetime(self.occurred, input_name='occurred'), namespace_, eol_))
        if self.dst is not None:
            self.dst.export(outfile, level, namespace_, name_='dst', pretty_print=pretty_print)
        if self.smtp_message is not None:
            self.smtp_message.export(outfile, level, namespace_, name_='smtp-message', pretty_print=pretty_print)
        if self.interface is not None:
            self.interface.export(outfile, level, namespace_, name_='interface', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='alert'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.product is not None and 'product' not in already_processed:
            already_processed.add('product')
            showIndent(outfile, level)
            outfile.write('product="%s",\n' % (self.product,))
        if self.severity is not None and 'severity' not in already_processed:
            already_processed.add('severity')
            showIndent(outfile, level)
            outfile.write('severity="%s",\n' % (self.severity,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            showIndent(outfile, level)
            outfile.write('version="%s",\n' % (self.version,))
        if self.sensor is not None and 'sensor' not in already_processed:
            already_processed.add('sensor')
            showIndent(outfile, level)
            outfile.write('sensor="%s",\n' % (self.sensor,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id=%d,\n' % (self.id,))
        if self.appliance_id is not None and 'appliance_id' not in already_processed:
            already_processed.add('appliance_id')
            showIndent(outfile, level)
            outfile.write('appliance_id="%s",\n' % (self.appliance_id,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.explanation is not None:
            showIndent(outfile, level)
            outfile.write('explanation=model_.explanation(\n')
            self.explanation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.src is not None:
            showIndent(outfile, level)
            outfile.write('src=model_.src(\n')
            self.src.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.alert_url is not None:
            showIndent(outfile, level)
            outfile.write('alert_url=%s,\n' % quote_python(self.alert_url).encode(ExternalEncoding))
        if self.action is not None:
            showIndent(outfile, level)
            outfile.write('action=%s,\n' % quote_python(self.action).encode(ExternalEncoding))
        if self.locations is not None:
            showIndent(outfile, level)
            outfile.write('locations=%s,\n' % quote_python(self.locations).encode(ExternalEncoding))
        if self.occurred is not None:
            showIndent(outfile, level)
            outfile.write('occurred=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.occurred, input_name='occurred'))
        if self.dst is not None:
            showIndent(outfile, level)
            outfile.write('dst=model_.dstType(\n')
            self.dst.exportLiteral(outfile, level, name_='dst')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.smtp_message is not None:
            showIndent(outfile, level)
            outfile.write('smtp_message=model_.smtp_messageType(\n')
            self.smtp_message.exportLiteral(outfile, level, name_='smtp_message')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.interface is not None:
            showIndent(outfile, level)
            outfile.write('interface=model_.interfaceType(\n')
            self.interface.exportLiteral(outfile, level, name_='interface')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('product', node)
        if value is not None and 'product' not in already_processed:
            already_processed.add('product')
            self.product = value
            self.validate_ProductType(self.product)    # validate type ProductType
        value = find_attr_value_('severity', node)
        if value is not None and 'severity' not in already_processed:
            already_processed.add('severity')
            self.severity = value
            self.validate_AlertSeverity(self.severity)    # validate type AlertSeverity
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
            self.validate_AlertType(self.name)    # validate type AlertType
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
        value = find_attr_value_('sensor', node)
        if value is not None and 'sensor' not in already_processed:
            already_processed.add('sensor')
            self.sensor = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            try:
                self.id = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('appliance-id', node)
        if value is not None and 'appliance-id' not in already_processed:
            already_processed.add('appliance-id')
            self.appliance_id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'explanation':
            obj_ = explanation.factory()
            obj_.build(child_)
            self.explanation = obj_
            obj_.original_tagname_ = 'explanation'
        elif nodeName_ == 'src':
            obj_ = src.factory()
            obj_.build(child_)
            self.src = obj_
            obj_.original_tagname_ = 'src'
        elif nodeName_ == 'alert-url':
            alert_url_ = child_.text
            alert_url_ = self.gds_validate_string(alert_url_, node, 'alert_url')
            self.alert_url = alert_url_
        elif nodeName_ == 'action':
            action_ = child_.text
            action_ = self.gds_validate_string(action_, node, 'action')
            self.action = action_
        elif nodeName_ == 'locations':
            locations_ = child_.text
            locations_ = self.gds_validate_string(locations_, node, 'locations')
            self.locations = locations_
        elif nodeName_ == 'occurred':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.occurred = dval_
            # validate type feDateTime
            self.validate_feDateTime(self.occurred)
        elif nodeName_ == 'dst':
            obj_ = dstType.factory()
            obj_.build(child_)
            self.dst = obj_
            obj_.original_tagname_ = 'dst'
        elif nodeName_ == 'smtp-message':
            obj_ = smtp_messageType.factory()
            obj_.build(child_)
            self.smtp_message = obj_
            obj_.original_tagname_ = 'smtp-message'
        elif nodeName_ == 'interface':
            obj_ = interfaceType.factory()
            obj_.build(child_)
            self.interface = obj_
            obj_.original_tagname_ = 'interface'
# end class alert


class explanation(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, protocol=None, urls=None, analysis=None, malware_detected=None, cnc_services=None, os_changes=None, static_analysis=None, service=None, anomaly=None, target_application=None, target_os=None, osinfo=None, stolen_data=None):
        self.original_tagname_ = None
        self.protocol = _cast(None, protocol)
        self.urls = _cast(int, urls)
        self.analysis = _cast(None, analysis)
        self.malware_detected = malware_detected
        self.cnc_services = cnc_services
        if os_changes is None:
            self.os_changes = []
        else:
            self.os_changes = os_changes
        self.static_analysis = static_analysis
        self.service = service
        self.anomaly = anomaly
        self.target_application = target_application
        self.target_os = target_os
        self.osinfo = osinfo
        self.stolen_data = stolen_data
    def factory(*args_, **kwargs_):
        if explanation.subclass:
            return explanation.subclass(*args_, **kwargs_)
        else:
            return explanation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_malware_detected(self): return self.malware_detected
    def set_malware_detected(self, malware_detected): self.malware_detected = malware_detected
    def get_cnc_services(self): return self.cnc_services
    def set_cnc_services(self, cnc_services): self.cnc_services = cnc_services
    def get_os_changes(self): return self.os_changes
    def set_os_changes(self, os_changes): self.os_changes = os_changes
    def add_os_changes(self, value): self.os_changes.append(value)
    def insert_os_changes_at(self, index, value): self.os_changes.insert(index, value)
    def replace_os_changes_at(self, index, value): self.os_changes[index] = value
    def get_static_analysis(self): return self.static_analysis
    def set_static_analysis(self, static_analysis): self.static_analysis = static_analysis
    def get_service(self): return self.service
    def set_service(self, service): self.service = service
    def get_anomaly(self): return self.anomaly
    def set_anomaly(self, anomaly): self.anomaly = anomaly
    def get_target_application(self): return self.target_application
    def set_target_application(self, target_application): self.target_application = target_application
    def get_target_os(self): return self.target_os
    def set_target_os(self, target_os): self.target_os = target_os
    def get_osinfo(self): return self.osinfo
    def set_osinfo(self, osinfo): self.osinfo = osinfo
    def get_stolen_data(self): return self.stolen_data
    def set_stolen_data(self, stolen_data): self.stolen_data = stolen_data
    def get_protocol(self): return self.protocol
    def set_protocol(self, protocol): self.protocol = protocol
    def get_urls(self): return self.urls
    def set_urls(self, urls): self.urls = urls
    def get_analysis(self): return self.analysis
    def set_analysis(self, analysis): self.analysis = analysis
    def hasContent_(self):
        if (
            self.malware_detected is not None or
            self.cnc_services is not None or
            self.os_changes or
            self.static_analysis is not None or
            self.service is not None or
            self.anomaly is not None or
            self.target_application is not None or
            self.target_os is not None or
            self.osinfo is not None or
            self.stolen_data is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='explanation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='explanation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='explanation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='explanation'):
        if self.protocol is not None and 'protocol' not in already_processed:
            already_processed.add('protocol')
            outfile.write(' protocol=%s' % (self.gds_format_string(quote_attrib(self.protocol).encode(ExternalEncoding), input_name='protocol'), ))
        if self.urls is not None and 'urls' not in already_processed:
            already_processed.add('urls')
            outfile.write(' urls="%s"' % self.gds_format_integer(self.urls, input_name='urls'))
        if self.analysis is not None and 'analysis' not in already_processed:
            already_processed.add('analysis')
            outfile.write(' analysis=%s' % (quote_attrib(self.analysis), ))
    def exportChildren(self, outfile, level, namespace_='', name_='explanation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.malware_detected is not None:
            self.malware_detected.export(outfile, level, namespace_, name_='malware-detected', pretty_print=pretty_print)
        if self.cnc_services is not None:
            self.cnc_services.export(outfile, level, namespace_, name_='cnc-services', pretty_print=pretty_print)
        for os_changes_ in self.os_changes:
            os_changes_.export(outfile, level, namespace_, name_='os-changes', pretty_print=pretty_print)
        if self.static_analysis is not None:
            self.static_analysis.export(outfile, level, namespace_, name_='static-analysis', pretty_print=pretty_print)
        if self.service is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sservice>%s</%sservice>%s' % (namespace_, self.gds_format_string(quote_xml(self.service).encode(ExternalEncoding), input_name='service'), namespace_, eol_))
        if self.anomaly is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sanomaly>%s</%sanomaly>%s' % (namespace_, self.gds_format_string(quote_xml(self.anomaly).encode(ExternalEncoding), input_name='anomaly'), namespace_, eol_))
        if self.target_application is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%starget-application>%s</%starget-application>%s' % (namespace_, self.gds_format_string(quote_xml(self.target_application).encode(ExternalEncoding), input_name='target-application'), namespace_, eol_))
        if self.target_os is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%starget-os>%s</%starget-os>%s' % (namespace_, self.gds_format_string(quote_xml(self.target_os).encode(ExternalEncoding), input_name='target-os'), namespace_, eol_))
        if self.osinfo is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sosinfo>%s</%sosinfo>%s' % (namespace_, self.gds_format_string(quote_xml(self.osinfo).encode(ExternalEncoding), input_name='osinfo'), namespace_, eol_))
        if self.stolen_data is not None:
            self.stolen_data.export(outfile, level, namespace_, name_='stolen_data', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='explanation'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.protocol is not None and 'protocol' not in already_processed:
            already_processed.add('protocol')
            showIndent(outfile, level)
            outfile.write('protocol="%s",\n' % (self.protocol,))
        if self.urls is not None and 'urls' not in already_processed:
            already_processed.add('urls')
            showIndent(outfile, level)
            outfile.write('urls=%d,\n' % (self.urls,))
        if self.analysis is not None and 'analysis' not in already_processed:
            already_processed.add('analysis')
            showIndent(outfile, level)
            outfile.write('analysis="%s",\n' % (self.analysis,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.malware_detected is not None:
            showIndent(outfile, level)
            outfile.write('malware_detected=model_.malware_detectedType(\n')
            self.malware_detected.exportLiteral(outfile, level, name_='malware_detected')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.cnc_services is not None:
            showIndent(outfile, level)
            outfile.write('cnc_services=model_.cnc_servicesType(\n')
            self.cnc_services.exportLiteral(outfile, level, name_='cnc_services')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('os_changes=[\n')
        level += 1
        for os_changes_ in self.os_changes:
            showIndent(outfile, level)
            outfile.write('model_.os_changesType(\n')
            os_changes_.exportLiteral(outfile, level, name_='os-changesType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.static_analysis is not None:
            showIndent(outfile, level)
            outfile.write('static_analysis=model_.static_analysisType(\n')
            self.static_analysis.exportLiteral(outfile, level, name_='static_analysis')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.service is not None:
            showIndent(outfile, level)
            outfile.write('service=%s,\n' % quote_python(self.service).encode(ExternalEncoding))
        if self.anomaly is not None:
            showIndent(outfile, level)
            outfile.write('anomaly=%s,\n' % quote_python(self.anomaly).encode(ExternalEncoding))
        if self.target_application is not None:
            showIndent(outfile, level)
            outfile.write('target_application=%s,\n' % quote_python(self.target_application).encode(ExternalEncoding))
        if self.target_os is not None:
            showIndent(outfile, level)
            outfile.write('target_os=%s,\n' % quote_python(self.target_os).encode(ExternalEncoding))
        if self.osinfo is not None:
            showIndent(outfile, level)
            outfile.write('osinfo=%s,\n' % quote_python(self.osinfo).encode(ExternalEncoding))
        if self.stolen_data is not None:
            showIndent(outfile, level)
            outfile.write('stolen_data=model_.stolen_data(\n')
            self.stolen_data.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('protocol', node)
        if value is not None and 'protocol' not in already_processed:
            already_processed.add('protocol')
            self.protocol = value
        value = find_attr_value_('urls', node)
        if value is not None and 'urls' not in already_processed:
            already_processed.add('urls')
            try:
                self.urls = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('analysis', node)
        if value is not None and 'analysis' not in already_processed:
            already_processed.add('analysis')
            self.analysis = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'malware-detected':
            obj_ = malware_detectedType.factory()
            obj_.build(child_)
            self.malware_detected = obj_
            obj_.original_tagname_ = 'malware-detected'
        elif nodeName_ == 'cnc-services':
            obj_ = cnc_servicesType.factory()
            obj_.build(child_)
            self.cnc_services = obj_
            obj_.original_tagname_ = 'cnc-services'
        elif nodeName_ == 'os-changes':
            obj_ = os_changesType.factory()
            obj_.build(child_)
            self.os_changes.append(obj_)
            obj_.original_tagname_ = 'os-changes'
        elif nodeName_ == 'static-analysis':
            obj_ = static_analysisType.factory()
            obj_.build(child_)
            self.static_analysis = obj_
            obj_.original_tagname_ = 'static-analysis'
        elif nodeName_ == 'service':
            service_ = child_.text
            service_ = self.gds_validate_string(service_, node, 'service')
            self.service = service_
        elif nodeName_ == 'anomaly':
            anomaly_ = child_.text
            anomaly_ = self.gds_validate_string(anomaly_, node, 'anomaly')
            self.anomaly = anomaly_
        elif nodeName_ == 'target-application':
            target_application_ = child_.text
            target_application_ = self.gds_validate_string(target_application_, node, 'target_application')
            self.target_application = target_application_
        elif nodeName_ == 'target-os':
            target_os_ = child_.text
            target_os_ = self.gds_validate_string(target_os_, node, 'target_os')
            self.target_os = target_os_
        elif nodeName_ == 'osinfo':
            osinfo_ = child_.text
            osinfo_ = self.gds_validate_string(osinfo_, node, 'osinfo')
            self.osinfo = osinfo_
        elif nodeName_ == 'stolen_data':
            obj_ = stolen_data.factory()
            obj_.build(child_)
            self.stolen_data = obj_
            obj_.original_tagname_ = 'stolen_data'
# end class explanation


class malware(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, parent=None, scan=None, origid=None, malicious=None, content=None, archives=None, sid=None, type_=None, stype=None, note=None, url=None, profile=None, md5sum=None, application=None, http_header=None, domain=None, user=None, original=None, downloaded_at=None, executed_at=None, objurl=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
        self.parent = _cast(int, parent)
        self.scan = _cast(int, scan)
        self.origid = _cast(int, origid)
        self.malicious = _cast(None, malicious)
        self.content = _cast(None, content)
        self.archives = _cast(int, archives)
        self.sid = _cast(None, sid)
        self.type_ = _cast(None, type_)
        self.stype = _cast(None, stype)
        self.note = note
        self.url = url
        self.profile = profile
        self.md5sum = md5sum
        self.application = application
        self.http_header = http_header
        self.domain = domain
        self.user = user
        self.original = original
        if isinstance(downloaded_at, basestring):
            initvalue_ = datetime_.datetime.strptime(downloaded_at, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = downloaded_at
        self.downloaded_at = initvalue_
        if isinstance(executed_at, basestring):
            initvalue_ = datetime_.datetime.strptime(executed_at, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = executed_at
        self.executed_at = initvalue_
        self.objurl = objurl
    def factory(*args_, **kwargs_):
        if malware.subclass:
            return malware.subclass(*args_, **kwargs_)
        else:
            return malware(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_note(self): return self.note
    def set_note(self, note): self.note = note
    def get_url(self): return self.url
    def set_url(self, url): self.url = url
    def get_profile(self): return self.profile
    def set_profile(self, profile): self.profile = profile
    def get_md5sum(self): return self.md5sum
    def set_md5sum(self, md5sum): self.md5sum = md5sum
    def get_application(self): return self.application
    def set_application(self, application): self.application = application
    def get_http_header(self): return self.http_header
    def set_http_header(self, http_header): self.http_header = http_header
    def get_domain(self): return self.domain
    def set_domain(self, domain): self.domain = domain
    def get_user(self): return self.user
    def set_user(self, user): self.user = user
    def get_original(self): return self.original
    def set_original(self, original): self.original = original
    def get_downloaded_at(self): return self.downloaded_at
    def set_downloaded_at(self, downloaded_at): self.downloaded_at = downloaded_at
    def get_executed_at(self): return self.executed_at
    def set_executed_at(self, executed_at): self.executed_at = executed_at
    def get_objurl(self): return self.objurl
    def set_objurl(self, objurl): self.objurl = objurl
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_parent(self): return self.parent
    def set_parent(self, parent): self.parent = parent
    def get_scan(self): return self.scan
    def set_scan(self, scan): self.scan = scan
    def get_origid(self): return self.origid
    def set_origid(self, origid): self.origid = origid
    def get_malicious(self): return self.malicious
    def set_malicious(self, malicious): self.malicious = malicious
    def get_content(self): return self.content
    def set_content(self, content): self.content = content
    def get_archives(self): return self.archives
    def set_archives(self, archives): self.archives = archives
    def get_sid(self): return self.sid
    def set_sid(self, sid): self.sid = sid
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_stype(self): return self.stype
    def set_stype(self, stype): self.stype = stype
    def validate_feDateTime(self, value):
        # Validate type feDateTime, a restriction on xs:dateTime.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.note is not None or
            self.url is not None or
            self.profile is not None or
            self.md5sum is not None or
            self.application is not None or
            self.http_header is not None or
            self.domain is not None or
            self.user is not None or
            self.original is not None or
            self.downloaded_at is not None or
            self.executed_at is not None or
            self.objurl is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='malware', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='malware')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='malware', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='malware'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.parent is not None and 'parent' not in already_processed:
            already_processed.add('parent')
            outfile.write(' parent="%s"' % self.gds_format_integer(self.parent, input_name='parent'))
        if self.scan is not None and 'scan' not in already_processed:
            already_processed.add('scan')
            outfile.write(' scan="%s"' % self.gds_format_integer(self.scan, input_name='scan'))
        if self.origid is not None and 'origid' not in already_processed:
            already_processed.add('origid')
            outfile.write(' origid="%s"' % self.gds_format_integer(self.origid, input_name='origid'))
        if self.malicious is not None and 'malicious' not in already_processed:
            already_processed.add('malicious')
            outfile.write(' malicious=%s' % (self.gds_format_string(quote_attrib(self.malicious).encode(ExternalEncoding), input_name='malicious'), ))
        if self.content is not None and 'content' not in already_processed:
            already_processed.add('content')
            outfile.write(' content=%s' % (self.gds_format_string(quote_attrib(self.content).encode(ExternalEncoding), input_name='content'), ))
        if self.archives is not None and 'archives' not in already_processed:
            already_processed.add('archives')
            outfile.write(' archives="%s"' % self.gds_format_integer(self.archives, input_name='archives'))
        if self.sid is not None and 'sid' not in already_processed:
            already_processed.add('sid')
            outfile.write(' sid=%s' % (self.gds_format_string(quote_attrib(self.sid).encode(ExternalEncoding), input_name='sid'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        if self.stype is not None and 'stype' not in already_processed:
            already_processed.add('stype')
            outfile.write(' stype=%s' % (self.gds_format_string(quote_attrib(self.stype).encode(ExternalEncoding), input_name='stype'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='malware', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.note is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snote>%s</%snote>%s' % (namespace_, self.gds_format_string(quote_xml(self.note).encode(ExternalEncoding), input_name='note'), namespace_, eol_))
        if self.url is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%surl>%s</%surl>%s' % (namespace_, self.gds_format_string(quote_xml(self.url).encode(ExternalEncoding), input_name='url'), namespace_, eol_))
        if self.profile is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprofile>%s</%sprofile>%s' % (namespace_, self.gds_format_string(quote_xml(self.profile).encode(ExternalEncoding), input_name='profile'), namespace_, eol_))
        if self.md5sum is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smd5sum>%s</%smd5sum>%s' % (namespace_, self.gds_format_string(quote_xml(self.md5sum).encode(ExternalEncoding), input_name='md5sum'), namespace_, eol_))
        if self.application is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sapplication>%s</%sapplication>%s' % (namespace_, self.gds_format_string(quote_xml(self.application).encode(ExternalEncoding), input_name='application'), namespace_, eol_))
        if self.http_header is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%shttp-header>%s</%shttp-header>%s' % (namespace_, self.gds_format_string(quote_xml(self.http_header).encode(ExternalEncoding), input_name='http-header'), namespace_, eol_))
        if self.domain is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdomain>%s</%sdomain>%s' % (namespace_, self.gds_format_string(quote_xml(self.domain).encode(ExternalEncoding), input_name='domain'), namespace_, eol_))
        if self.user is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%suser>%s</%suser>%s' % (namespace_, self.gds_format_string(quote_xml(self.user).encode(ExternalEncoding), input_name='user'), namespace_, eol_))
        if self.original is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soriginal>%s</%soriginal>%s' % (namespace_, self.gds_format_string(quote_xml(self.original).encode(ExternalEncoding), input_name='original'), namespace_, eol_))
        if self.downloaded_at is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdownloaded-at>%s</%sdownloaded-at>%s' % (namespace_, self.gds_format_datetime(self.downloaded_at, input_name='downloaded-at'), namespace_, eol_))
        if self.executed_at is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sexecuted-at>%s</%sexecuted-at>%s' % (namespace_, self.gds_format_datetime(self.executed_at, input_name='executed-at'), namespace_, eol_))
        if self.objurl is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sobjurl>%s</%sobjurl>%s' % (namespace_, self.gds_format_string(quote_xml(self.objurl).encode(ExternalEncoding), input_name='objurl'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='malware'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.parent is not None and 'parent' not in already_processed:
            already_processed.add('parent')
            showIndent(outfile, level)
            outfile.write('parent=%d,\n' % (self.parent,))
        if self.scan is not None and 'scan' not in already_processed:
            already_processed.add('scan')
            showIndent(outfile, level)
            outfile.write('scan=%d,\n' % (self.scan,))
        if self.origid is not None and 'origid' not in already_processed:
            already_processed.add('origid')
            showIndent(outfile, level)
            outfile.write('origid=%d,\n' % (self.origid,))
        if self.malicious is not None and 'malicious' not in already_processed:
            already_processed.add('malicious')
            showIndent(outfile, level)
            outfile.write('malicious="%s",\n' % (self.malicious,))
        if self.content is not None and 'content' not in already_processed:
            already_processed.add('content')
            showIndent(outfile, level)
            outfile.write('content="%s",\n' % (self.content,))
        if self.archives is not None and 'archives' not in already_processed:
            already_processed.add('archives')
            showIndent(outfile, level)
            outfile.write('archives=%d,\n' % (self.archives,))
        if self.sid is not None and 'sid' not in already_processed:
            already_processed.add('sid')
            showIndent(outfile, level)
            outfile.write('sid="%s",\n' % (self.sid,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
        if self.stype is not None and 'stype' not in already_processed:
            already_processed.add('stype')
            showIndent(outfile, level)
            outfile.write('stype="%s",\n' % (self.stype,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.note is not None:
            showIndent(outfile, level)
            outfile.write('note=%s,\n' % quote_python(self.note).encode(ExternalEncoding))
        if self.url is not None:
            showIndent(outfile, level)
            outfile.write('url=%s,\n' % quote_python(self.url).encode(ExternalEncoding))
        if self.profile is not None:
            showIndent(outfile, level)
            outfile.write('profile=%s,\n' % quote_python(self.profile).encode(ExternalEncoding))
        if self.md5sum is not None:
            showIndent(outfile, level)
            outfile.write('md5sum=%s,\n' % quote_python(self.md5sum).encode(ExternalEncoding))
        if self.application is not None:
            showIndent(outfile, level)
            outfile.write('application=%s,\n' % quote_python(self.application).encode(ExternalEncoding))
        if self.http_header is not None:
            showIndent(outfile, level)
            outfile.write('http_header=%s,\n' % quote_python(self.http_header).encode(ExternalEncoding))
        if self.domain is not None:
            showIndent(outfile, level)
            outfile.write('domain=%s,\n' % quote_python(self.domain).encode(ExternalEncoding))
        if self.user is not None:
            showIndent(outfile, level)
            outfile.write('user=%s,\n' % quote_python(self.user).encode(ExternalEncoding))
        if self.original is not None:
            showIndent(outfile, level)
            outfile.write('original=%s,\n' % quote_python(self.original).encode(ExternalEncoding))
        if self.downloaded_at is not None:
            showIndent(outfile, level)
            outfile.write('downloaded_at=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.downloaded_at, input_name='downloaded_at'))
        if self.executed_at is not None:
            showIndent(outfile, level)
            outfile.write('executed_at=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.executed_at, input_name='executed_at'))
        if self.objurl is not None:
            showIndent(outfile, level)
            outfile.write('objurl=%s,\n' % quote_python(self.objurl).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('parent', node)
        if value is not None and 'parent' not in already_processed:
            already_processed.add('parent')
            try:
                self.parent = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('scan', node)
        if value is not None and 'scan' not in already_processed:
            already_processed.add('scan')
            try:
                self.scan = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('origid', node)
        if value is not None and 'origid' not in already_processed:
            already_processed.add('origid')
            try:
                self.origid = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('malicious', node)
        if value is not None and 'malicious' not in already_processed:
            already_processed.add('malicious')
            self.malicious = value
        value = find_attr_value_('content', node)
        if value is not None and 'content' not in already_processed:
            already_processed.add('content')
            self.content = value
        value = find_attr_value_('archives', node)
        if value is not None and 'archives' not in already_processed:
            already_processed.add('archives')
            try:
                self.archives = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('sid', node)
        if value is not None and 'sid' not in already_processed:
            already_processed.add('sid')
            self.sid = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('stype', node)
        if value is not None and 'stype' not in already_processed:
            already_processed.add('stype')
            self.stype = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'note':
            note_ = child_.text
            note_ = self.gds_validate_string(note_, node, 'note')
            self.note = note_
        elif nodeName_ == 'url':
            url_ = child_.text
            url_ = self.gds_validate_string(url_, node, 'url')
            self.url = url_
        elif nodeName_ == 'profile':
            profile_ = child_.text
            profile_ = self.gds_validate_string(profile_, node, 'profile')
            self.profile = profile_
        elif nodeName_ == 'md5sum':
            md5sum_ = child_.text
            md5sum_ = self.gds_validate_string(md5sum_, node, 'md5sum')
            self.md5sum = md5sum_
        elif nodeName_ == 'application':
            application_ = child_.text
            application_ = self.gds_validate_string(application_, node, 'application')
            self.application = application_
        elif nodeName_ == 'http-header':
            http_header_ = child_.text
            http_header_ = self.gds_validate_string(http_header_, node, 'http_header')
            self.http_header = http_header_
        elif nodeName_ == 'domain':
            domain_ = child_.text
            domain_ = self.gds_validate_string(domain_, node, 'domain')
            self.domain = domain_
        elif nodeName_ == 'user':
            user_ = child_.text
            user_ = self.gds_validate_string(user_, node, 'user')
            self.user = user_
        elif nodeName_ == 'original':
            original_ = child_.text
            original_ = self.gds_validate_string(original_, node, 'original')
            self.original = original_
        elif nodeName_ == 'downloaded-at':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.downloaded_at = dval_
            # validate type feDateTime
            self.validate_feDateTime(self.downloaded_at)
        elif nodeName_ == 'executed-at':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.executed_at = dval_
            # validate type feDateTime
            self.validate_feDateTime(self.executed_at)
        elif nodeName_ == 'objurl':
            objurl_ = child_.text
            objurl_ = self.gds_validate_string(objurl_, node, 'objurl')
            self.objurl = objurl_
# end class malware


class cnc_service(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, protocol=None, port=None, address=None, channel=None, location=None):
        self.original_tagname_ = None
        self.protocol = _cast(None, protocol)
        self.port = _cast(int, port)
        self.address = address
        self.channel = channel
        self.location = location
    def factory(*args_, **kwargs_):
        if cnc_service.subclass:
            return cnc_service.subclass(*args_, **kwargs_)
        else:
            return cnc_service(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_address(self): return self.address
    def set_address(self, address): self.address = address
    def get_channel(self): return self.channel
    def set_channel(self, channel): self.channel = channel
    def get_location(self): return self.location
    def set_location(self, location): self.location = location
    def get_protocol(self): return self.protocol
    def set_protocol(self, protocol): self.protocol = protocol
    def get_port(self): return self.port
    def set_port(self, port): self.port = port
    def hasContent_(self):
        if (
            self.address is not None or
            self.channel is not None or
            self.location is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='cnc-service', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cnc-service')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='cnc-service', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='cnc-service'):
        if self.protocol is not None and 'protocol' not in already_processed:
            already_processed.add('protocol')
            outfile.write(' protocol=%s' % (quote_attrib(self.protocol), ))
        if self.port is not None and 'port' not in already_processed:
            already_processed.add('port')
            outfile.write(' port="%s"' % self.gds_format_integer(self.port, input_name='port'))
    def exportChildren(self, outfile, level, namespace_='', name_='cnc-service', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.address is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saddress>%s</%saddress>%s' % (namespace_, self.gds_format_string(quote_xml(self.address).encode(ExternalEncoding), input_name='address'), namespace_, eol_))
        if self.channel is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%schannel>%s</%schannel>%s' % (namespace_, self.gds_format_string(quote_xml(self.channel).encode(ExternalEncoding), input_name='channel'), namespace_, eol_))
        if self.location is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slocation>%s</%slocation>%s' % (namespace_, self.gds_format_string(quote_xml(self.location).encode(ExternalEncoding), input_name='location'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='cnc-service'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.protocol is not None and 'protocol' not in already_processed:
            already_processed.add('protocol')
            showIndent(outfile, level)
            outfile.write('protocol="%s",\n' % (self.protocol,))
        if self.port is not None and 'port' not in already_processed:
            already_processed.add('port')
            showIndent(outfile, level)
            outfile.write('port=%d,\n' % (self.port,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.address is not None:
            showIndent(outfile, level)
            outfile.write('address=%s,\n' % quote_python(self.address).encode(ExternalEncoding))
        if self.channel is not None:
            showIndent(outfile, level)
            outfile.write('channel=%s,\n' % quote_python(self.channel).encode(ExternalEncoding))
        if self.location is not None:
            showIndent(outfile, level)
            outfile.write('location=%s,\n' % quote_python(self.location).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('protocol', node)
        if value is not None and 'protocol' not in already_processed:
            already_processed.add('protocol')
            self.protocol = value
        value = find_attr_value_('port', node)
        if value is not None and 'port' not in already_processed:
            already_processed.add('port')
            try:
                self.port = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'address':
            address_ = child_.text
            address_ = self.gds_validate_string(address_, node, 'address')
            self.address = address_
        elif nodeName_ == 'channel':
            channel_ = child_.text
            channel_ = self.gds_validate_string(channel_, node, 'channel')
            self.channel = channel_
        elif nodeName_ == 'location':
            location_ = child_.text
            location_ = self.gds_validate_string(location_, node, 'location')
            self.location = location_
# end class cnc_service


class stolen_data(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, event_id=None, size=None, info=None):
        self.original_tagname_ = None
        self.event_id = _cast(int, event_id)
        self.size = _cast(int, size)
        self.info = info
    def factory(*args_, **kwargs_):
        if stolen_data.subclass:
            return stolen_data.subclass(*args_, **kwargs_)
        else:
            return stolen_data(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_info(self): return self.info
    def set_info(self, info): self.info = info
    def get_event_id(self): return self.event_id
    def set_event_id(self, event_id): self.event_id = event_id
    def get_size(self): return self.size
    def set_size(self, size): self.size = size
    def hasContent_(self):
        if (
            self.info is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='stolen_data', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='stolen_data')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='stolen_data', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='stolen_data'):
        if self.event_id is not None and 'event_id' not in already_processed:
            already_processed.add('event_id')
            outfile.write(' event_id="%s"' % self.gds_format_integer(self.event_id, input_name='event_id'))
        if self.size is not None and 'size' not in already_processed:
            already_processed.add('size')
            outfile.write(' size="%s"' % self.gds_format_integer(self.size, input_name='size'))
    def exportChildren(self, outfile, level, namespace_='', name_='stolen_data', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.info is not None:
            self.info.export(outfile, level, namespace_, name_='info', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='stolen_data'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.event_id is not None and 'event_id' not in already_processed:
            already_processed.add('event_id')
            showIndent(outfile, level)
            outfile.write('event_id=%d,\n' % (self.event_id,))
        if self.size is not None and 'size' not in already_processed:
            already_processed.add('size')
            showIndent(outfile, level)
            outfile.write('size=%d,\n' % (self.size,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.info is not None:
            showIndent(outfile, level)
            outfile.write('info=model_.info(\n')
            self.info.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('event_id', node)
        if value is not None and 'event_id' not in already_processed:
            already_processed.add('event_id')
            try:
                self.event_id = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('size', node)
        if value is not None and 'size' not in already_processed:
            already_processed.add('size')
            try:
                self.size = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'info':
            obj_ = info.factory()
            obj_.build(child_)
            self.info = obj_
            obj_.original_tagname_ = 'info'
# end class stolen_data


class info(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, decrypted=None, type_=None, encryption=None, description=None, severity=None, field=None):
        self.original_tagname_ = None
        self.decrypted = _cast(None, decrypted)
        self.type_ = _cast(None, type_)
        self.encryption = _cast(None, encryption)
        self.description = description
        self.severity = severity
        if field is None:
            self.field = []
        else:
            self.field = field
    def factory(*args_, **kwargs_):
        if info.subclass:
            return info.subclass(*args_, **kwargs_)
        else:
            return info(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_severity(self): return self.severity
    def set_severity(self, severity): self.severity = severity
    def get_field(self): return self.field
    def set_field(self, field): self.field = field
    def add_field(self, value): self.field.append(value)
    def insert_field_at(self, index, value): self.field.insert(index, value)
    def replace_field_at(self, index, value): self.field[index] = value
    def get_decrypted(self): return self.decrypted
    def set_decrypted(self, decrypted): self.decrypted = decrypted
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_encryption(self): return self.encryption
    def set_encryption(self, encryption): self.encryption = encryption
    def hasContent_(self):
        if (
            self.description is not None or
            self.severity is not None or
            self.field
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='info', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='info')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='info', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='info'):
        if self.decrypted is not None and 'decrypted' not in already_processed:
            already_processed.add('decrypted')
            outfile.write(' decrypted=%s' % (self.gds_format_string(quote_attrib(self.decrypted).encode(ExternalEncoding), input_name='decrypted'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        if self.encryption is not None and 'encryption' not in already_processed:
            already_processed.add('encryption')
            outfile.write(' encryption=%s' % (self.gds_format_string(quote_attrib(self.encryption).encode(ExternalEncoding), input_name='encryption'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='info', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.description).encode(ExternalEncoding), input_name='description'), namespace_, eol_))
        if self.severity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sseverity>%s</%sseverity>%s' % (namespace_, self.gds_format_string(quote_xml(self.severity).encode(ExternalEncoding), input_name='severity'), namespace_, eol_))
        for field_ in self.field:
            field_.export(outfile, level, namespace_, name_='field', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='info'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.decrypted is not None and 'decrypted' not in already_processed:
            already_processed.add('decrypted')
            showIndent(outfile, level)
            outfile.write('decrypted="%s",\n' % (self.decrypted,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
        if self.encryption is not None and 'encryption' not in already_processed:
            already_processed.add('encryption')
            showIndent(outfile, level)
            outfile.write('encryption="%s",\n' % (self.encryption,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=%s,\n' % quote_python(self.description).encode(ExternalEncoding))
        if self.severity is not None:
            showIndent(outfile, level)
            outfile.write('severity=%s,\n' % quote_python(self.severity).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('field=[\n')
        level += 1
        for field_ in self.field:
            showIndent(outfile, level)
            outfile.write('model_.field(\n')
            field_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('decrypted', node)
        if value is not None and 'decrypted' not in already_processed:
            already_processed.add('decrypted')
            self.decrypted = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('encryption', node)
        if value is not None and 'encryption' not in already_processed:
            already_processed.add('encryption')
            self.encryption = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'severity':
            severity_ = child_.text
            severity_ = self.gds_validate_string(severity_, node, 'severity')
            self.severity = severity_
        elif nodeName_ == 'field':
            obj_ = field.factory()
            obj_.build(child_)
            self.field.append(obj_)
            obj_.original_tagname_ = 'field'
# end class info


class field(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, valueOf_=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if field.subclass:
            return field.subclass(*args_, **kwargs_)
        else:
            return field(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='field', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='field')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='field', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='field'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='field', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='field'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class field


class src(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, vlan=None, ip=None, mac=None, host=None, port=None, domain=None, smtp_mail_from=None, repository=None, url=None, proxy=None):
        self.original_tagname_ = None
        self.vlan = _cast(int, vlan)
        self.ip = ip
        self.mac = mac
        self.host = host
        self.port = port
        self.domain = domain
        self.smtp_mail_from = smtp_mail_from
        self.repository = repository
        self.url = url
        self.proxy = proxy
    def factory(*args_, **kwargs_):
        if src.subclass:
            return src.subclass(*args_, **kwargs_)
        else:
            return src(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ip(self): return self.ip
    def set_ip(self, ip): self.ip = ip
    def get_mac(self): return self.mac
    def set_mac(self, mac): self.mac = mac
    def get_host(self): return self.host
    def set_host(self, host): self.host = host
    def get_port(self): return self.port
    def set_port(self, port): self.port = port
    def get_domain(self): return self.domain
    def set_domain(self, domain): self.domain = domain
    def get_smtp_mail_from(self): return self.smtp_mail_from
    def set_smtp_mail_from(self, smtp_mail_from): self.smtp_mail_from = smtp_mail_from
    def get_repository(self): return self.repository
    def set_repository(self, repository): self.repository = repository
    def get_url(self): return self.url
    def set_url(self, url): self.url = url
    def get_proxy(self): return self.proxy
    def set_proxy(self, proxy): self.proxy = proxy
    def get_vlan(self): return self.vlan
    def set_vlan(self, vlan): self.vlan = vlan
    def hasContent_(self):
        if (
            self.ip is not None or
            self.mac is not None or
            self.host is not None or
            self.port is not None or
            self.domain is not None or
            self.smtp_mail_from is not None or
            self.repository is not None or
            self.url is not None or
            self.proxy is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='src', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='src')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='src', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='src'):
        if self.vlan is not None and 'vlan' not in already_processed:
            already_processed.add('vlan')
            outfile.write(' vlan="%s"' % self.gds_format_integer(self.vlan, input_name='vlan'))
    def exportChildren(self, outfile, level, namespace_='', name_='src', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ip is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sip>%s</%sip>%s' % (namespace_, self.gds_format_string(quote_xml(self.ip).encode(ExternalEncoding), input_name='ip'), namespace_, eol_))
        if self.mac is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smac>%s</%smac>%s' % (namespace_, self.gds_format_string(quote_xml(self.mac).encode(ExternalEncoding), input_name='mac'), namespace_, eol_))
        if self.host is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%shost>%s</%shost>%s' % (namespace_, self.gds_format_string(quote_xml(self.host).encode(ExternalEncoding), input_name='host'), namespace_, eol_))
        if self.port is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sport>%s</%sport>%s' % (namespace_, self.gds_format_integer(self.port, input_name='port'), namespace_, eol_))
        if self.domain is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdomain>%s</%sdomain>%s' % (namespace_, self.gds_format_string(quote_xml(self.domain).encode(ExternalEncoding), input_name='domain'), namespace_, eol_))
        if self.smtp_mail_from is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssmtp-mail-from>%s</%ssmtp-mail-from>%s' % (namespace_, self.gds_format_string(quote_xml(self.smtp_mail_from).encode(ExternalEncoding), input_name='smtp-mail-from'), namespace_, eol_))
        if self.repository is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srepository>%s</%srepository>%s' % (namespace_, self.gds_format_string(quote_xml(self.repository).encode(ExternalEncoding), input_name='repository'), namespace_, eol_))
        if self.url is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%surl>%s</%surl>%s' % (namespace_, self.gds_format_string(quote_xml(self.url).encode(ExternalEncoding), input_name='url'), namespace_, eol_))
        if self.proxy is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sproxy>%s</%sproxy>%s' % (namespace_, self.gds_format_string(quote_xml(self.proxy).encode(ExternalEncoding), input_name='proxy'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='src'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.vlan is not None and 'vlan' not in already_processed:
            already_processed.add('vlan')
            showIndent(outfile, level)
            outfile.write('vlan=%d,\n' % (self.vlan,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ip is not None:
            showIndent(outfile, level)
            outfile.write('ip=%s,\n' % quote_python(self.ip).encode(ExternalEncoding))
        if self.mac is not None:
            showIndent(outfile, level)
            outfile.write('mac=%s,\n' % quote_python(self.mac).encode(ExternalEncoding))
        if self.host is not None:
            showIndent(outfile, level)
            outfile.write('host=%s,\n' % quote_python(self.host).encode(ExternalEncoding))
        if self.port is not None:
            showIndent(outfile, level)
            outfile.write('port=%d,\n' % self.port)
        if self.domain is not None:
            showIndent(outfile, level)
            outfile.write('domain=%s,\n' % quote_python(self.domain).encode(ExternalEncoding))
        if self.smtp_mail_from is not None:
            showIndent(outfile, level)
            outfile.write('smtp_mail_from=%s,\n' % quote_python(self.smtp_mail_from).encode(ExternalEncoding))
        if self.repository is not None:
            showIndent(outfile, level)
            outfile.write('repository=%s,\n' % quote_python(self.repository).encode(ExternalEncoding))
        if self.url is not None:
            showIndent(outfile, level)
            outfile.write('url=%s,\n' % quote_python(self.url).encode(ExternalEncoding))
        if self.proxy is not None:
            showIndent(outfile, level)
            outfile.write('proxy=%s,\n' % quote_python(self.proxy).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('vlan', node)
        if value is not None and 'vlan' not in already_processed:
            already_processed.add('vlan')
            try:
                self.vlan = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ip':
            ip_ = child_.text
            ip_ = self.gds_validate_string(ip_, node, 'ip')
            self.ip = ip_
        elif nodeName_ == 'mac':
            mac_ = child_.text
            mac_ = self.gds_validate_string(mac_, node, 'mac')
            self.mac = mac_
        elif nodeName_ == 'host':
            host_ = child_.text
            host_ = self.gds_validate_string(host_, node, 'host')
            self.host = host_
        elif nodeName_ == 'port':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'port')
            self.port = ival_
        elif nodeName_ == 'domain':
            domain_ = child_.text
            domain_ = self.gds_validate_string(domain_, node, 'domain')
            self.domain = domain_
        elif nodeName_ == 'smtp-mail-from':
            smtp_mail_from_ = child_.text
            smtp_mail_from_ = self.gds_validate_string(smtp_mail_from_, node, 'smtp_mail_from')
            self.smtp_mail_from = smtp_mail_from_
        elif nodeName_ == 'repository':
            repository_ = child_.text
            repository_ = self.gds_validate_string(repository_, node, 'repository')
            self.repository = repository_
        elif nodeName_ == 'url':
            url_ = child_.text
            url_ = self.gds_validate_string(url_, node, 'url')
            self.url = url_
        elif nodeName_ == 'proxy':
            proxy_ = child_.text
            proxy_ = self.gds_validate_string(proxy_, node, 'proxy')
            self.proxy = proxy_
# end class src


class static(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, tool=None, version=None, valueOf_=None):
        self.original_tagname_ = None
        self.tool = _cast(None, tool)
        self.version = _cast(None, version)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if static.subclass:
            return static.subclass(*args_, **kwargs_)
        else:
            return static(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tool(self): return self.tool
    def set_tool(self, tool): self.tool = tool
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='static', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='static')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='static', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='static'):
        if self.tool is not None and 'tool' not in already_processed:
            already_processed.add('tool')
            outfile.write(' tool=%s' % (self.gds_format_string(quote_attrib(self.tool).encode(ExternalEncoding), input_name='tool'), ))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (self.gds_format_string(quote_attrib(self.version).encode(ExternalEncoding), input_name='version'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='static', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='static'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.tool is not None and 'tool' not in already_processed:
            already_processed.add('tool')
            showIndent(outfile, level)
            outfile.write('tool="%s",\n' % (self.tool,))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            showIndent(outfile, level)
            outfile.write('version="%s",\n' % (self.version,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('tool', node)
        if value is not None and 'tool' not in already_processed:
            already_processed.add('tool')
            self.tool = value
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class static


class OSCChangeSet(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, analysis=None, os=None, os_monitor=None, event_logger=None, apicall=None, application=None, codeinjection=None, driver=None, exploitcode=None, file=None, folder=None, heapspraying=None, malicious_alert=None, mutex=None, network=None, process=None, process_packed=None, processstats=None, regkey=None, uac=None, keyloggerdetected=None, HardwareAccessDetection=None, dll_loaded=None, appexception=None, debugcontrol=None, hiddenproc=None, dll_exports=None, guestos_not_pingable=None, SSDT=None, spooler_dll_injection=None, detection_monitor_killed=None, started=None, firefox=None, AsyncKeyLogger=None, CmdLine=None, systemshutdown=None, os_inactivity_send_keys=None, end_of_report=None, extensiontype_=None):
        self.original_tagname_ = None
        self.analysis = analysis
        self.os = os
        self.os_monitor = os_monitor
        self.event_logger = event_logger
        if apicall is None:
            self.apicall = []
        else:
            self.apicall = apicall
        if application is None:
            self.application = []
        else:
            self.application = application
        if codeinjection is None:
            self.codeinjection = []
        else:
            self.codeinjection = codeinjection
        if driver is None:
            self.driver = []
        else:
            self.driver = driver
        if exploitcode is None:
            self.exploitcode = []
        else:
            self.exploitcode = exploitcode
        if file is None:
            self.file = []
        else:
            self.file = file
        if folder is None:
            self.folder = []
        else:
            self.folder = folder
        if heapspraying is None:
            self.heapspraying = []
        else:
            self.heapspraying = heapspraying
        if malicious_alert is None:
            self.malicious_alert = []
        else:
            self.malicious_alert = malicious_alert
        if mutex is None:
            self.mutex = []
        else:
            self.mutex = mutex
        if network is None:
            self.network = []
        else:
            self.network = network
        if process is None:
            self.process = []
        else:
            self.process = process
        if process_packed is None:
            self.process_packed = []
        else:
            self.process_packed = process_packed
        if processstats is None:
            self.processstats = []
        else:
            self.processstats = processstats
        if regkey is None:
            self.regkey = []
        else:
            self.regkey = regkey
        if uac is None:
            self.uac = []
        else:
            self.uac = uac
        if keyloggerdetected is None:
            self.keyloggerdetected = []
        else:
            self.keyloggerdetected = keyloggerdetected
        if HardwareAccessDetection is None:
            self.HardwareAccessDetection = []
        else:
            self.HardwareAccessDetection = HardwareAccessDetection
        if dll_loaded is None:
            self.dll_loaded = []
        else:
            self.dll_loaded = dll_loaded
        if appexception is None:
            self.appexception = []
        else:
            self.appexception = appexception
        if debugcontrol is None:
            self.debugcontrol = []
        else:
            self.debugcontrol = debugcontrol
        if hiddenproc is None:
            self.hiddenproc = []
        else:
            self.hiddenproc = hiddenproc
        if dll_exports is None:
            self.dll_exports = []
        else:
            self.dll_exports = dll_exports
        if guestos_not_pingable is None:
            self.guestos_not_pingable = []
        else:
            self.guestos_not_pingable = guestos_not_pingable
        if SSDT is None:
            self.SSDT = []
        else:
            self.SSDT = SSDT
        if spooler_dll_injection is None:
            self.spooler_dll_injection = []
        else:
            self.spooler_dll_injection = spooler_dll_injection
        if detection_monitor_killed is None:
            self.detection_monitor_killed = []
        else:
            self.detection_monitor_killed = detection_monitor_killed
        if started is None:
            self.started = []
        else:
            self.started = started
        if firefox is None:
            self.firefox = []
        else:
            self.firefox = firefox
        if AsyncKeyLogger is None:
            self.AsyncKeyLogger = []
        else:
            self.AsyncKeyLogger = AsyncKeyLogger
        if CmdLine is None:
            self.CmdLine = []
        else:
            self.CmdLine = CmdLine
        if systemshutdown is None:
            self.systemshutdown = []
        else:
            self.systemshutdown = systemshutdown
        if os_inactivity_send_keys is None:
            self.os_inactivity_send_keys = []
        else:
            self.os_inactivity_send_keys = os_inactivity_send_keys
        self.end_of_report = end_of_report
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if OSCChangeSet.subclass:
            return OSCChangeSet.subclass(*args_, **kwargs_)
        else:
            return OSCChangeSet(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_analysis(self): return self.analysis
    def set_analysis(self, analysis): self.analysis = analysis
    def get_os(self): return self.os
    def set_os(self, os): self.os = os
    def get_os_monitor(self): return self.os_monitor
    def set_os_monitor(self, os_monitor): self.os_monitor = os_monitor
    def get_event_logger(self): return self.event_logger
    def set_event_logger(self, event_logger): self.event_logger = event_logger
    def get_apicall(self): return self.apicall
    def set_apicall(self, apicall): self.apicall = apicall
    def add_apicall(self, value): self.apicall.append(value)
    def insert_apicall_at(self, index, value): self.apicall.insert(index, value)
    def replace_apicall_at(self, index, value): self.apicall[index] = value
    def get_application(self): return self.application
    def set_application(self, application): self.application = application
    def add_application(self, value): self.application.append(value)
    def insert_application_at(self, index, value): self.application.insert(index, value)
    def replace_application_at(self, index, value): self.application[index] = value
    def get_codeinjection(self): return self.codeinjection
    def set_codeinjection(self, codeinjection): self.codeinjection = codeinjection
    def add_codeinjection(self, value): self.codeinjection.append(value)
    def insert_codeinjection_at(self, index, value): self.codeinjection.insert(index, value)
    def replace_codeinjection_at(self, index, value): self.codeinjection[index] = value
    def get_driver(self): return self.driver
    def set_driver(self, driver): self.driver = driver
    def add_driver(self, value): self.driver.append(value)
    def insert_driver_at(self, index, value): self.driver.insert(index, value)
    def replace_driver_at(self, index, value): self.driver[index] = value
    def get_exploitcode(self): return self.exploitcode
    def set_exploitcode(self, exploitcode): self.exploitcode = exploitcode
    def add_exploitcode(self, value): self.exploitcode.append(value)
    def insert_exploitcode_at(self, index, value): self.exploitcode.insert(index, value)
    def replace_exploitcode_at(self, index, value): self.exploitcode[index] = value
    def get_file(self): return self.file
    def set_file(self, file): self.file = file
    def add_file(self, value): self.file.append(value)
    def insert_file_at(self, index, value): self.file.insert(index, value)
    def replace_file_at(self, index, value): self.file[index] = value
    def get_folder(self): return self.folder
    def set_folder(self, folder): self.folder = folder
    def add_folder(self, value): self.folder.append(value)
    def insert_folder_at(self, index, value): self.folder.insert(index, value)
    def replace_folder_at(self, index, value): self.folder[index] = value
    def get_heapspraying(self): return self.heapspraying
    def set_heapspraying(self, heapspraying): self.heapspraying = heapspraying
    def add_heapspraying(self, value): self.heapspraying.append(value)
    def insert_heapspraying_at(self, index, value): self.heapspraying.insert(index, value)
    def replace_heapspraying_at(self, index, value): self.heapspraying[index] = value
    def get_malicious_alert(self): return self.malicious_alert
    def set_malicious_alert(self, malicious_alert): self.malicious_alert = malicious_alert
    def add_malicious_alert(self, value): self.malicious_alert.append(value)
    def insert_malicious_alert_at(self, index, value): self.malicious_alert.insert(index, value)
    def replace_malicious_alert_at(self, index, value): self.malicious_alert[index] = value
    def get_mutex(self): return self.mutex
    def set_mutex(self, mutex): self.mutex = mutex
    def add_mutex(self, value): self.mutex.append(value)
    def insert_mutex_at(self, index, value): self.mutex.insert(index, value)
    def replace_mutex_at(self, index, value): self.mutex[index] = value
    def get_network(self): return self.network
    def set_network(self, network): self.network = network
    def add_network(self, value): self.network.append(value)
    def insert_network_at(self, index, value): self.network.insert(index, value)
    def replace_network_at(self, index, value): self.network[index] = value
    def get_process(self): return self.process
    def set_process(self, process): self.process = process
    def add_process(self, value): self.process.append(value)
    def insert_process_at(self, index, value): self.process.insert(index, value)
    def replace_process_at(self, index, value): self.process[index] = value
    def get_process_packed(self): return self.process_packed
    def set_process_packed(self, process_packed): self.process_packed = process_packed
    def add_process_packed(self, value): self.process_packed.append(value)
    def insert_process_packed_at(self, index, value): self.process_packed.insert(index, value)
    def replace_process_packed_at(self, index, value): self.process_packed[index] = value
    def get_processstats(self): return self.processstats
    def set_processstats(self, processstats): self.processstats = processstats
    def add_processstats(self, value): self.processstats.append(value)
    def insert_processstats_at(self, index, value): self.processstats.insert(index, value)
    def replace_processstats_at(self, index, value): self.processstats[index] = value
    def get_regkey(self): return self.regkey
    def set_regkey(self, regkey): self.regkey = regkey
    def add_regkey(self, value): self.regkey.append(value)
    def insert_regkey_at(self, index, value): self.regkey.insert(index, value)
    def replace_regkey_at(self, index, value): self.regkey[index] = value
    def get_uac(self): return self.uac
    def set_uac(self, uac): self.uac = uac
    def add_uac(self, value): self.uac.append(value)
    def insert_uac_at(self, index, value): self.uac.insert(index, value)
    def replace_uac_at(self, index, value): self.uac[index] = value
    def get_keyloggerdetected(self): return self.keyloggerdetected
    def set_keyloggerdetected(self, keyloggerdetected): self.keyloggerdetected = keyloggerdetected
    def add_keyloggerdetected(self, value): self.keyloggerdetected.append(value)
    def insert_keyloggerdetected_at(self, index, value): self.keyloggerdetected.insert(index, value)
    def replace_keyloggerdetected_at(self, index, value): self.keyloggerdetected[index] = value
    def get_HardwareAccessDetection(self): return self.HardwareAccessDetection
    def set_HardwareAccessDetection(self, HardwareAccessDetection): self.HardwareAccessDetection = HardwareAccessDetection
    def add_HardwareAccessDetection(self, value): self.HardwareAccessDetection.append(value)
    def insert_HardwareAccessDetection_at(self, index, value): self.HardwareAccessDetection.insert(index, value)
    def replace_HardwareAccessDetection_at(self, index, value): self.HardwareAccessDetection[index] = value
    def get_dll_loaded(self): return self.dll_loaded
    def set_dll_loaded(self, dll_loaded): self.dll_loaded = dll_loaded
    def add_dll_loaded(self, value): self.dll_loaded.append(value)
    def insert_dll_loaded_at(self, index, value): self.dll_loaded.insert(index, value)
    def replace_dll_loaded_at(self, index, value): self.dll_loaded[index] = value
    def get_appexception(self): return self.appexception
    def set_appexception(self, appexception): self.appexception = appexception
    def add_appexception(self, value): self.appexception.append(value)
    def insert_appexception_at(self, index, value): self.appexception.insert(index, value)
    def replace_appexception_at(self, index, value): self.appexception[index] = value
    def get_debugcontrol(self): return self.debugcontrol
    def set_debugcontrol(self, debugcontrol): self.debugcontrol = debugcontrol
    def add_debugcontrol(self, value): self.debugcontrol.append(value)
    def insert_debugcontrol_at(self, index, value): self.debugcontrol.insert(index, value)
    def replace_debugcontrol_at(self, index, value): self.debugcontrol[index] = value
    def get_hiddenproc(self): return self.hiddenproc
    def set_hiddenproc(self, hiddenproc): self.hiddenproc = hiddenproc
    def add_hiddenproc(self, value): self.hiddenproc.append(value)
    def insert_hiddenproc_at(self, index, value): self.hiddenproc.insert(index, value)
    def replace_hiddenproc_at(self, index, value): self.hiddenproc[index] = value
    def get_dll_exports(self): return self.dll_exports
    def set_dll_exports(self, dll_exports): self.dll_exports = dll_exports
    def add_dll_exports(self, value): self.dll_exports.append(value)
    def insert_dll_exports_at(self, index, value): self.dll_exports.insert(index, value)
    def replace_dll_exports_at(self, index, value): self.dll_exports[index] = value
    def get_guestos_not_pingable(self): return self.guestos_not_pingable
    def set_guestos_not_pingable(self, guestos_not_pingable): self.guestos_not_pingable = guestos_not_pingable
    def add_guestos_not_pingable(self, value): self.guestos_not_pingable.append(value)
    def insert_guestos_not_pingable_at(self, index, value): self.guestos_not_pingable.insert(index, value)
    def replace_guestos_not_pingable_at(self, index, value): self.guestos_not_pingable[index] = value
    def get_SSDT(self): return self.SSDT
    def set_SSDT(self, SSDT): self.SSDT = SSDT
    def add_SSDT(self, value): self.SSDT.append(value)
    def insert_SSDT_at(self, index, value): self.SSDT.insert(index, value)
    def replace_SSDT_at(self, index, value): self.SSDT[index] = value
    def get_spooler_dll_injection(self): return self.spooler_dll_injection
    def set_spooler_dll_injection(self, spooler_dll_injection): self.spooler_dll_injection = spooler_dll_injection
    def add_spooler_dll_injection(self, value): self.spooler_dll_injection.append(value)
    def insert_spooler_dll_injection_at(self, index, value): self.spooler_dll_injection.insert(index, value)
    def replace_spooler_dll_injection_at(self, index, value): self.spooler_dll_injection[index] = value
    def get_detection_monitor_killed(self): return self.detection_monitor_killed
    def set_detection_monitor_killed(self, detection_monitor_killed): self.detection_monitor_killed = detection_monitor_killed
    def add_detection_monitor_killed(self, value): self.detection_monitor_killed.append(value)
    def insert_detection_monitor_killed_at(self, index, value): self.detection_monitor_killed.insert(index, value)
    def replace_detection_monitor_killed_at(self, index, value): self.detection_monitor_killed[index] = value
    def get_started(self): return self.started
    def set_started(self, started): self.started = started
    def add_started(self, value): self.started.append(value)
    def insert_started_at(self, index, value): self.started.insert(index, value)
    def replace_started_at(self, index, value): self.started[index] = value
    def get_firefox(self): return self.firefox
    def set_firefox(self, firefox): self.firefox = firefox
    def add_firefox(self, value): self.firefox.append(value)
    def insert_firefox_at(self, index, value): self.firefox.insert(index, value)
    def replace_firefox_at(self, index, value): self.firefox[index] = value
    def get_AsyncKeyLogger(self): return self.AsyncKeyLogger
    def set_AsyncKeyLogger(self, AsyncKeyLogger): self.AsyncKeyLogger = AsyncKeyLogger
    def add_AsyncKeyLogger(self, value): self.AsyncKeyLogger.append(value)
    def insert_AsyncKeyLogger_at(self, index, value): self.AsyncKeyLogger.insert(index, value)
    def replace_AsyncKeyLogger_at(self, index, value): self.AsyncKeyLogger[index] = value
    def get_CmdLine(self): return self.CmdLine
    def set_CmdLine(self, CmdLine): self.CmdLine = CmdLine
    def add_CmdLine(self, value): self.CmdLine.append(value)
    def insert_CmdLine_at(self, index, value): self.CmdLine.insert(index, value)
    def replace_CmdLine_at(self, index, value): self.CmdLine[index] = value
    def get_systemshutdown(self): return self.systemshutdown
    def set_systemshutdown(self, systemshutdown): self.systemshutdown = systemshutdown
    def add_systemshutdown(self, value): self.systemshutdown.append(value)
    def insert_systemshutdown_at(self, index, value): self.systemshutdown.insert(index, value)
    def replace_systemshutdown_at(self, index, value): self.systemshutdown[index] = value
    def get_os_inactivity_send_keys(self): return self.os_inactivity_send_keys
    def set_os_inactivity_send_keys(self, os_inactivity_send_keys): self.os_inactivity_send_keys = os_inactivity_send_keys
    def add_os_inactivity_send_keys(self, value): self.os_inactivity_send_keys.append(value)
    def insert_os_inactivity_send_keys_at(self, index, value): self.os_inactivity_send_keys.insert(index, value)
    def replace_os_inactivity_send_keys_at(self, index, value): self.os_inactivity_send_keys[index] = value
    def get_end_of_report(self): return self.end_of_report
    def set_end_of_report(self, end_of_report): self.end_of_report = end_of_report
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.analysis is not None or
            self.os is not None or
            self.os_monitor is not None or
            self.event_logger is not None or
            self.apicall or
            self.application or
            self.codeinjection or
            self.driver or
            self.exploitcode or
            self.file or
            self.folder or
            self.heapspraying or
            self.malicious_alert or
            self.mutex or
            self.network or
            self.process or
            self.process_packed or
            self.processstats or
            self.regkey or
            self.uac or
            self.keyloggerdetected or
            self.HardwareAccessDetection or
            self.dll_loaded or
            self.appexception or
            self.debugcontrol or
            self.hiddenproc or
            self.dll_exports or
            self.guestos_not_pingable or
            self.SSDT or
            self.spooler_dll_injection or
            self.detection_monitor_killed or
            self.started or
            self.firefox or
            self.AsyncKeyLogger or
            self.CmdLine or
            self.systemshutdown or
            self.os_inactivity_send_keys or
            self.end_of_report is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OSCChangeSet', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OSCChangeSet')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OSCChangeSet', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OSCChangeSet'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='OSCChangeSet', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.analysis is not None:
            self.analysis.export(outfile, level, namespace_, name_='analysis', pretty_print=pretty_print)
        if self.os is not None:
            self.os.export(outfile, level, namespace_, name_='os', pretty_print=pretty_print)
        if self.os_monitor is not None:
            self.os_monitor.export(outfile, level, namespace_, name_='os_monitor', pretty_print=pretty_print)
        if self.event_logger is not None:
            self.event_logger.export(outfile, level, namespace_, name_='event_logger', pretty_print=pretty_print)
        for apicall_ in self.apicall:
            apicall_.export(outfile, level, namespace_, name_='apicall', pretty_print=pretty_print)
        for application_ in self.application:
            application_.export(outfile, level, namespace_, name_='application', pretty_print=pretty_print)
        for codeinjection_ in self.codeinjection:
            codeinjection_.export(outfile, level, namespace_, name_='codeinjection', pretty_print=pretty_print)
        for driver_ in self.driver:
            driver_.export(outfile, level, namespace_, name_='driver', pretty_print=pretty_print)
        for exploitcode_ in self.exploitcode:
            exploitcode_.export(outfile, level, namespace_, name_='exploitcode', pretty_print=pretty_print)
        for file_ in self.file:
            file_.export(outfile, level, namespace_, name_='file', pretty_print=pretty_print)
        for folder_ in self.folder:
            folder_.export(outfile, level, namespace_, name_='folder', pretty_print=pretty_print)
        for heapspraying_ in self.heapspraying:
            heapspraying_.export(outfile, level, namespace_, name_='heapspraying', pretty_print=pretty_print)
        for malicious_alert_ in self.malicious_alert:
            malicious_alert_.export(outfile, level, namespace_, name_='malicious-alert', pretty_print=pretty_print)
        for mutex_ in self.mutex:
            mutex_.export(outfile, level, namespace_, name_='mutex', pretty_print=pretty_print)
        for network_ in self.network:
            network_.export(outfile, level, namespace_, name_='network', pretty_print=pretty_print)
        for process_ in self.process:
            process_.export(outfile, level, namespace_, name_='process', pretty_print=pretty_print)
        for process_packed_ in self.process_packed:
            process_packed_.export(outfile, level, namespace_, name_='process-packed', pretty_print=pretty_print)
        for processstats_ in self.processstats:
            processstats_.export(outfile, level, namespace_, name_='processstats', pretty_print=pretty_print)
        for regkey_ in self.regkey:
            regkey_.export(outfile, level, namespace_, name_='regkey', pretty_print=pretty_print)
        for uac_ in self.uac:
            uac_.export(outfile, level, namespace_, name_='uac', pretty_print=pretty_print)
        for keyloggerdetected_ in self.keyloggerdetected:
            keyloggerdetected_.export(outfile, level, namespace_, name_='keyloggerdetected', pretty_print=pretty_print)
        for HardwareAccessDetection_ in self.HardwareAccessDetection:
            HardwareAccessDetection_.export(outfile, level, namespace_, name_='HardwareAccessDetection', pretty_print=pretty_print)
        for dll_loaded_ in self.dll_loaded:
            dll_loaded_.export(outfile, level, namespace_, name_='dll-loaded', pretty_print=pretty_print)
        for appexception_ in self.appexception:
            appexception_.export(outfile, level, namespace_, name_='appexception', pretty_print=pretty_print)
        for debugcontrol_ in self.debugcontrol:
            debugcontrol_.export(outfile, level, namespace_, name_='debugcontrol', pretty_print=pretty_print)
        for hiddenproc_ in self.hiddenproc:
            hiddenproc_.export(outfile, level, namespace_, name_='hiddenproc', pretty_print=pretty_print)
        for dll_exports_ in self.dll_exports:
            dll_exports_.export(outfile, level, namespace_, name_='dll-exports', pretty_print=pretty_print)
        for guestos_not_pingable_ in self.guestos_not_pingable:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sguestos-not-pingable>%s</%sguestos-not-pingable>%s' % (namespace_, self.gds_format_string(quote_xml(guestos_not_pingable_).encode(ExternalEncoding), input_name='guestos-not-pingable'), namespace_, eol_))
        for SSDT_ in self.SSDT:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSSDT>%s</%sSSDT>%s' % (namespace_, self.gds_format_string(quote_xml(SSDT_).encode(ExternalEncoding), input_name='SSDT'), namespace_, eol_))
        for spooler_dll_injection_ in self.spooler_dll_injection:
            spooler_dll_injection_.export(outfile, level, namespace_, name_='spooler-dll-injection', pretty_print=pretty_print)
        for detection_monitor_killed_ in self.detection_monitor_killed:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdetection-monitor-killed>%s</%sdetection-monitor-killed>%s' % (namespace_, self.gds_format_string(quote_xml(detection_monitor_killed_).encode(ExternalEncoding), input_name='detection-monitor-killed'), namespace_, eol_))
        for started_ in self.started:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstarted>%s</%sstarted>%s' % (namespace_, self.gds_format_string(quote_xml(started_).encode(ExternalEncoding), input_name='started'), namespace_, eol_))
        for firefox_ in self.firefox:
            firefox_.export(outfile, level, namespace_, name_='firefox', pretty_print=pretty_print)
        for AsyncKeyLogger_ in self.AsyncKeyLogger:
            AsyncKeyLogger_.export(outfile, level, namespace_, name_='AsyncKeyLogger', pretty_print=pretty_print)
        for CmdLine_ in self.CmdLine:
            CmdLine_.export(outfile, level, namespace_, name_='CmdLine', pretty_print=pretty_print)
        for systemshutdown_ in self.systemshutdown:
            systemshutdown_.export(outfile, level, namespace_, name_='systemshutdown', pretty_print=pretty_print)
        for os_inactivity_send_keys_ in self.os_inactivity_send_keys:
            os_inactivity_send_keys_.export(outfile, level, namespace_, name_='os-inactivity-send-keys', pretty_print=pretty_print)
        if self.end_of_report is not None:
            self.end_of_report.export(outfile, level, namespace_, name_='end-of-report', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='OSCChangeSet'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.analysis is not None:
            showIndent(outfile, level)
            outfile.write('analysis=model_.analysis(\n')
            self.analysis.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.os is not None:
            showIndent(outfile, level)
            outfile.write('os=model_.os(\n')
            self.os.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.os_monitor is not None:
            showIndent(outfile, level)
            outfile.write('os_monitor=model_.os_monitor(\n')
            self.os_monitor.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.event_logger is not None:
            showIndent(outfile, level)
            outfile.write('event_logger=model_.event_logger(\n')
            self.event_logger.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('apicall=[\n')
        level += 1
        for apicall_ in self.apicall:
            showIndent(outfile, level)
            outfile.write('model_.apicall(\n')
            apicall_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('application=[\n')
        level += 1
        for application_ in self.application:
            showIndent(outfile, level)
            outfile.write('model_.application(\n')
            application_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('codeinjection=[\n')
        level += 1
        for codeinjection_ in self.codeinjection:
            showIndent(outfile, level)
            outfile.write('model_.codeinjection(\n')
            codeinjection_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('driver=[\n')
        level += 1
        for driver_ in self.driver:
            showIndent(outfile, level)
            outfile.write('model_.driver(\n')
            driver_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('exploitcode=[\n')
        level += 1
        for exploitcode_ in self.exploitcode:
            showIndent(outfile, level)
            outfile.write('model_.exploitcode(\n')
            exploitcode_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('file=[\n')
        level += 1
        for file_ in self.file:
            showIndent(outfile, level)
            outfile.write('model_.file(\n')
            file_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('folder=[\n')
        level += 1
        for folder_ in self.folder:
            showIndent(outfile, level)
            outfile.write('model_.folder(\n')
            folder_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('heapspraying=[\n')
        level += 1
        for heapspraying_ in self.heapspraying:
            showIndent(outfile, level)
            outfile.write('model_.heapspraying(\n')
            heapspraying_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('malicious_alert=[\n')
        level += 1
        for malicious_alert_ in self.malicious_alert:
            showIndent(outfile, level)
            outfile.write('model_.malicious_alert(\n')
            malicious_alert_.exportLiteral(outfile, level, name_='malicious-alert')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('mutex=[\n')
        level += 1
        for mutex_ in self.mutex:
            showIndent(outfile, level)
            outfile.write('model_.mutex(\n')
            mutex_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('network=[\n')
        level += 1
        for network_ in self.network:
            showIndent(outfile, level)
            outfile.write('model_.network(\n')
            network_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('process=[\n')
        level += 1
        for process_ in self.process:
            showIndent(outfile, level)
            outfile.write('model_.process(\n')
            process_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('process_packed=[\n')
        level += 1
        for process_packed_ in self.process_packed:
            showIndent(outfile, level)
            outfile.write('model_.process_packed(\n')
            process_packed_.exportLiteral(outfile, level, name_='process-packed')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('processstats=[\n')
        level += 1
        for processstats_ in self.processstats:
            showIndent(outfile, level)
            outfile.write('model_.processstats(\n')
            processstats_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('regkey=[\n')
        level += 1
        for regkey_ in self.regkey:
            showIndent(outfile, level)
            outfile.write('model_.regkey(\n')
            regkey_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('uac=[\n')
        level += 1
        for uac_ in self.uac:
            showIndent(outfile, level)
            outfile.write('model_.uac(\n')
            uac_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('keyloggerdetected=[\n')
        level += 1
        for keyloggerdetected_ in self.keyloggerdetected:
            showIndent(outfile, level)
            outfile.write('model_.keyloggerdetected(\n')
            keyloggerdetected_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('HardwareAccessDetection=[\n')
        level += 1
        for HardwareAccessDetection_ in self.HardwareAccessDetection:
            showIndent(outfile, level)
            outfile.write('model_.HardwareAccessDetection(\n')
            HardwareAccessDetection_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('dll_loaded=[\n')
        level += 1
        for dll_loaded_ in self.dll_loaded:
            showIndent(outfile, level)
            outfile.write('model_.dll_loaded(\n')
            dll_loaded_.exportLiteral(outfile, level, name_='dll-loaded')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('appexception=[\n')
        level += 1
        for appexception_ in self.appexception:
            showIndent(outfile, level)
            outfile.write('model_.appexception(\n')
            appexception_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('debugcontrol=[\n')
        level += 1
        for debugcontrol_ in self.debugcontrol:
            showIndent(outfile, level)
            outfile.write('model_.debugcontrol(\n')
            debugcontrol_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('hiddenproc=[\n')
        level += 1
        for hiddenproc_ in self.hiddenproc:
            showIndent(outfile, level)
            outfile.write('model_.hiddenproc(\n')
            hiddenproc_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('dll_exports=[\n')
        level += 1
        for dll_exports_ in self.dll_exports:
            showIndent(outfile, level)
            outfile.write('model_.dll_exports(\n')
            dll_exports_.exportLiteral(outfile, level, name_='dll-exports')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('guestos_not_pingable=[\n')
        level += 1
        for guestos_not_pingable_ in self.guestos_not_pingable:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(guestos_not_pingable_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('SSDT=[\n')
        level += 1
        for SSDT_ in self.SSDT:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(SSDT_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('spooler_dll_injection=[\n')
        level += 1
        for spooler_dll_injection_ in self.spooler_dll_injection:
            showIndent(outfile, level)
            outfile.write('model_.spooler_dll_injection(\n')
            spooler_dll_injection_.exportLiteral(outfile, level, name_='spooler-dll-injection')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('detection_monitor_killed=[\n')
        level += 1
        for detection_monitor_killed_ in self.detection_monitor_killed:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(detection_monitor_killed_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('started=[\n')
        level += 1
        for started_ in self.started:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(started_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('firefox=[\n')
        level += 1
        for firefox_ in self.firefox:
            showIndent(outfile, level)
            outfile.write('model_.firefox(\n')
            firefox_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('AsyncKeyLogger=[\n')
        level += 1
        for AsyncKeyLogger_ in self.AsyncKeyLogger:
            showIndent(outfile, level)
            outfile.write('model_.AsyncKeyLogger(\n')
            AsyncKeyLogger_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('CmdLine=[\n')
        level += 1
        for CmdLine_ in self.CmdLine:
            showIndent(outfile, level)
            outfile.write('model_.CmdLine(\n')
            CmdLine_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('systemshutdown=[\n')
        level += 1
        for systemshutdown_ in self.systemshutdown:
            showIndent(outfile, level)
            outfile.write('model_.systemshutdown(\n')
            systemshutdown_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('os_inactivity_send_keys=[\n')
        level += 1
        for os_inactivity_send_keys_ in self.os_inactivity_send_keys:
            showIndent(outfile, level)
            outfile.write('model_.os_inactivity_send_keys(\n')
            os_inactivity_send_keys_.exportLiteral(outfile, level, name_='os-inactivity-send-keys')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.end_of_report is not None:
            showIndent(outfile, level)
            outfile.write('end_of_report=model_.end_of_report(\n')
            self.end_of_report.exportLiteral(outfile, level, name_='end_of_report')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'analysis':
            obj_ = analysis.factory()
            obj_.build(child_)
            self.analysis = obj_
            obj_.original_tagname_ = 'analysis'
        elif nodeName_ == 'os':
            obj_ = os.factory()
            obj_.build(child_)
            self.os = obj_
            obj_.original_tagname_ = 'os'
        elif nodeName_ == 'os_monitor':
            obj_ = os_monitor.factory()
            obj_.build(child_)
            self.os_monitor = obj_
            obj_.original_tagname_ = 'os_monitor'
        elif nodeName_ == 'event_logger':
            obj_ = event_logger.factory()
            obj_.build(child_)
            self.event_logger = obj_
            obj_.original_tagname_ = 'event_logger'
        elif nodeName_ == 'apicall':
            obj_ = apicall.factory()
            obj_.build(child_)
            self.apicall.append(obj_)
            obj_.original_tagname_ = 'apicall'
        elif nodeName_ == 'application':
            obj_ = application.factory()
            obj_.build(child_)
            self.application.append(obj_)
            obj_.original_tagname_ = 'application'
        elif nodeName_ == 'codeinjection':
            obj_ = codeinjection.factory()
            obj_.build(child_)
            self.codeinjection.append(obj_)
            obj_.original_tagname_ = 'codeinjection'
        elif nodeName_ == 'driver':
            obj_ = driver.factory()
            obj_.build(child_)
            self.driver.append(obj_)
            obj_.original_tagname_ = 'driver'
        elif nodeName_ == 'exploitcode':
            obj_ = exploitcode.factory()
            obj_.build(child_)
            self.exploitcode.append(obj_)
            obj_.original_tagname_ = 'exploitcode'
        elif nodeName_ == 'file':
            obj_ = file.factory()
            obj_.build(child_)
            self.file.append(obj_)
            obj_.original_tagname_ = 'file'
        elif nodeName_ == 'folder':
            obj_ = folder.factory()
            obj_.build(child_)
            self.folder.append(obj_)
            obj_.original_tagname_ = 'folder'
        elif nodeName_ == 'heapspraying':
            obj_ = heapspraying.factory()
            obj_.build(child_)
            self.heapspraying.append(obj_)
            obj_.original_tagname_ = 'heapspraying'
        elif nodeName_ == 'malicious-alert':
            obj_ = malicious_alert.factory()
            obj_.build(child_)
            self.malicious_alert.append(obj_)
            obj_.original_tagname_ = 'malicious-alert'
        elif nodeName_ == 'mutex':
            obj_ = mutex.factory()
            obj_.build(child_)
            self.mutex.append(obj_)
            obj_.original_tagname_ = 'mutex'
        elif nodeName_ == 'network':
            obj_ = network.factory()
            obj_.build(child_)
            self.network.append(obj_)
            obj_.original_tagname_ = 'network'
        elif nodeName_ == 'process':
            obj_ = process.factory()
            obj_.build(child_)
            self.process.append(obj_)
            obj_.original_tagname_ = 'process'
        elif nodeName_ == 'process-packed':
            obj_ = process_packed.factory()
            obj_.build(child_)
            self.process_packed.append(obj_)
            obj_.original_tagname_ = 'process-packed'
        elif nodeName_ == 'processstats':
            obj_ = processstats.factory()
            obj_.build(child_)
            self.processstats.append(obj_)
            obj_.original_tagname_ = 'processstats'
        elif nodeName_ == 'regkey':
            obj_ = regkey.factory()
            obj_.build(child_)
            self.regkey.append(obj_)
            obj_.original_tagname_ = 'regkey'
        elif nodeName_ == 'uac':
            obj_ = uac.factory()
            obj_.build(child_)
            self.uac.append(obj_)
            obj_.original_tagname_ = 'uac'
        elif nodeName_ == 'keyloggerdetected':
            obj_ = keyloggerdetected.factory()
            obj_.build(child_)
            self.keyloggerdetected.append(obj_)
            obj_.original_tagname_ = 'keyloggerdetected'
        elif nodeName_ == 'HardwareAccessDetection':
            obj_ = HardwareAccessDetection.factory()
            obj_.build(child_)
            self.HardwareAccessDetection.append(obj_)
            obj_.original_tagname_ = 'HardwareAccessDetection'
        elif nodeName_ == 'dll-loaded':
            obj_ = dll_loaded.factory()
            obj_.build(child_)
            self.dll_loaded.append(obj_)
            obj_.original_tagname_ = 'dll-loaded'
        elif nodeName_ == 'appexception':
            obj_ = appexception.factory()
            obj_.build(child_)
            self.appexception.append(obj_)
            obj_.original_tagname_ = 'appexception'
        elif nodeName_ == 'debugcontrol':
            obj_ = debugcontrol.factory()
            obj_.build(child_)
            self.debugcontrol.append(obj_)
            obj_.original_tagname_ = 'debugcontrol'
        elif nodeName_ == 'hiddenproc':
            obj_ = hiddenproc.factory()
            obj_.build(child_)
            self.hiddenproc.append(obj_)
            obj_.original_tagname_ = 'hiddenproc'
        elif nodeName_ == 'dll-exports':
            obj_ = dll_exports.factory()
            obj_.build(child_)
            self.dll_exports.append(obj_)
            obj_.original_tagname_ = 'dll-exports'
        elif nodeName_ == 'guestos-not-pingable':
            guestos_not_pingable_ = child_.text
            guestos_not_pingable_ = self.gds_validate_string(guestos_not_pingable_, node, 'guestos_not_pingable')
            self.guestos_not_pingable.append(guestos_not_pingable_)
        elif nodeName_ == 'SSDT':
            SSDT_ = child_.text
            SSDT_ = self.gds_validate_string(SSDT_, node, 'SSDT')
            self.SSDT.append(SSDT_)
        elif nodeName_ == 'spooler-dll-injection':
            obj_ = spooler_dll_injection.factory()
            obj_.build(child_)
            self.spooler_dll_injection.append(obj_)
            obj_.original_tagname_ = 'spooler-dll-injection'
        elif nodeName_ == 'detection-monitor-killed':
            detection_monitor_killed_ = child_.text
            detection_monitor_killed_ = self.gds_validate_string(detection_monitor_killed_, node, 'detection_monitor_killed')
            self.detection_monitor_killed.append(detection_monitor_killed_)
        elif nodeName_ == 'started':
            started_ = child_.text
            started_ = self.gds_validate_string(started_, node, 'started')
            self.started.append(started_)
        elif nodeName_ == 'firefox':
            obj_ = firefox.factory()
            obj_.build(child_)
            self.firefox.append(obj_)
            obj_.original_tagname_ = 'firefox'
        elif nodeName_ == 'AsyncKeyLogger':
            obj_ = AsyncKeyLogger.factory()
            obj_.build(child_)
            self.AsyncKeyLogger.append(obj_)
            obj_.original_tagname_ = 'AsyncKeyLogger'
        elif nodeName_ == 'CmdLine':
            obj_ = CmdLine.factory()
            obj_.build(child_)
            self.CmdLine.append(obj_)
            obj_.original_tagname_ = 'CmdLine'
        elif nodeName_ == 'systemshutdown':
            obj_ = systemshutdown.factory()
            obj_.build(child_)
            self.systemshutdown.append(obj_)
            obj_.original_tagname_ = 'systemshutdown'
        elif nodeName_ == 'os-inactivity-send-keys':
            obj_ = os_inactivity_send_keys.factory()
            obj_.build(child_)
            self.os_inactivity_send_keys.append(obj_)
            obj_.original_tagname_ = 'os-inactivity-send-keys'
        elif nodeName_ == 'end-of-report':
            obj_ = end_of_report.factory()
            obj_.build(child_)
            self.end_of_report = obj_
            obj_.original_tagname_ = 'end-of-report'
# end class OSCChangeSet


class application(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, app_name=None, sequenceNumber=None):
        self.original_tagname_ = None
        self.app_name = _cast(None, app_name)
        self.sequenceNumber = _cast(None, sequenceNumber)
    def factory(*args_, **kwargs_):
        if application.subclass:
            return application.subclass(*args_, **kwargs_)
        else:
            return application(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_app_name(self): return self.app_name
    def set_app_name(self, app_name): self.app_name = app_name
    def get_sequenceNumber(self): return self.sequenceNumber
    def set_sequenceNumber(self, sequenceNumber): self.sequenceNumber = sequenceNumber
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='application', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='application')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='application', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='application'):
        if self.app_name is not None and 'app_name' not in already_processed:
            already_processed.add('app_name')
            outfile.write(' app-name=%s' % (self.gds_format_string(quote_attrib(self.app_name).encode(ExternalEncoding), input_name='app-name'), ))
        if self.sequenceNumber is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            outfile.write(' sequenceNumber=%s' % (self.gds_format_string(quote_attrib(self.sequenceNumber).encode(ExternalEncoding), input_name='sequenceNumber'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='application', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='application'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.app_name is not None and 'app_name' not in already_processed:
            already_processed.add('app_name')
            showIndent(outfile, level)
            outfile.write('app_name="%s",\n' % (self.app_name,))
        if self.sequenceNumber is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            showIndent(outfile, level)
            outfile.write('sequenceNumber="%s",\n' % (self.sequenceNumber,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('app-name', node)
        if value is not None and 'app-name' not in already_processed:
            already_processed.add('app-name')
            self.app_name = value
        value = find_attr_value_('sequenceNumber', node)
        if value is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            self.sequenceNumber = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class application


class os(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, sequenceNumber=None, sp=None, name=None, version=None):
        self.original_tagname_ = None
        self.sequenceNumber = _cast(None, sequenceNumber)
        self.sp = _cast(None, sp)
        self.name = _cast(None, name)
        self.version = _cast(None, version)
    def factory(*args_, **kwargs_):
        if os.subclass:
            return os.subclass(*args_, **kwargs_)
        else:
            return os(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_sequenceNumber(self): return self.sequenceNumber
    def set_sequenceNumber(self, sequenceNumber): self.sequenceNumber = sequenceNumber
    def get_sp(self): return self.sp
    def set_sp(self, sp): self.sp = sp
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='os', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='os')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='os', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='os'):
        if self.sequenceNumber is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            outfile.write(' sequenceNumber=%s' % (self.gds_format_string(quote_attrib(self.sequenceNumber).encode(ExternalEncoding), input_name='sequenceNumber'), ))
        if self.sp is not None and 'sp' not in already_processed:
            already_processed.add('sp')
            outfile.write(' sp=%s' % (self.gds_format_string(quote_attrib(self.sp).encode(ExternalEncoding), input_name='sp'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (self.gds_format_string(quote_attrib(self.version).encode(ExternalEncoding), input_name='version'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='os', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='os'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.sequenceNumber is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            showIndent(outfile, level)
            outfile.write('sequenceNumber="%s",\n' % (self.sequenceNumber,))
        if self.sp is not None and 'sp' not in already_processed:
            already_processed.add('sp')
            showIndent(outfile, level)
            outfile.write('sp="%s",\n' % (self.sp,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            showIndent(outfile, level)
            outfile.write('version="%s",\n' % (self.version,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sequenceNumber', node)
        if value is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            self.sequenceNumber = value
        value = find_attr_value_('sp', node)
        if value is not None and 'sp' not in already_processed:
            already_processed.add('sp')
            self.sp = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class os


class event_logger(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, date=None, build_=None, time=None):
        self.original_tagname_ = None
        self.date = _cast(None, date)
        self.build_ = _cast(None, build_)
        self.time = _cast(None, time)
    def factory(*args_, **kwargs_):
        if event_logger.subclass:
            return event_logger.subclass(*args_, **kwargs_)
        else:
            return event_logger(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_date(self): return self.date
    def set_date(self, date): self.date = date
    def get_build(self): return self.build_
    def set_build(self, build_): self.build_ = build_
    def get_time(self): return self.time
    def set_time(self, time): self.time = time
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='event_logger', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='event_logger')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='event_logger', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='event_logger'):
        if self.date is not None and 'date' not in already_processed:
            already_processed.add('date')
            outfile.write(' date=%s' % (self.gds_format_string(quote_attrib(self.date).encode(ExternalEncoding), input_name='date'), ))
        if self.build_ is not None and 'build_' not in already_processed:
            already_processed.add('build_')
            outfile.write(' build=%s' % (self.gds_format_string(quote_attrib(self.build_).encode(ExternalEncoding), input_name='build'), ))
        if self.time is not None and 'time' not in already_processed:
            already_processed.add('time')
            outfile.write(' time=%s' % (self.gds_format_string(quote_attrib(self.time).encode(ExternalEncoding), input_name='time'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='event_logger', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='event_logger'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.date is not None and 'date' not in already_processed:
            already_processed.add('date')
            showIndent(outfile, level)
            outfile.write('date="%s",\n' % (self.date,))
        if self.build_ is not None and 'build_' not in already_processed:
            already_processed.add('build_')
            showIndent(outfile, level)
            outfile.write('build_="%s",\n' % (self.build_,))
        if self.time is not None and 'time' not in already_processed:
            already_processed.add('time')
            showIndent(outfile, level)
            outfile.write('time="%s",\n' % (self.time,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('date', node)
        if value is not None and 'date' not in already_processed:
            already_processed.add('date')
            self.date = value
        value = find_attr_value_('build', node)
        if value is not None and 'build' not in already_processed:
            already_processed.add('build')
            self.build_ = value
        value = find_attr_value_('time', node)
        if value is not None and 'time' not in already_processed:
            already_processed.add('time')
            self.time = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class event_logger


class analysis(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, sequenceNumber=None, product=None, ftype=None, mode=None, version=None):
        self.original_tagname_ = None
        self.sequenceNumber = _cast(None, sequenceNumber)
        self.product = _cast(None, product)
        self.ftype = _cast(None, ftype)
        self.mode = _cast(None, mode)
        self.version = _cast(None, version)
    def factory(*args_, **kwargs_):
        if analysis.subclass:
            return analysis.subclass(*args_, **kwargs_)
        else:
            return analysis(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_sequenceNumber(self): return self.sequenceNumber
    def set_sequenceNumber(self, sequenceNumber): self.sequenceNumber = sequenceNumber
    def get_product(self): return self.product
    def set_product(self, product): self.product = product
    def get_ftype(self): return self.ftype
    def set_ftype(self, ftype): self.ftype = ftype
    def get_mode(self): return self.mode
    def set_mode(self, mode): self.mode = mode
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def validate_ProductTypeShort(self, value):
        # Validate type ProductTypeShort, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['MPS', 'eMPS']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ProductTypeShort' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='analysis', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='analysis')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='analysis', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='analysis'):
        if self.sequenceNumber is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            outfile.write(' sequenceNumber=%s' % (self.gds_format_string(quote_attrib(self.sequenceNumber).encode(ExternalEncoding), input_name='sequenceNumber'), ))
        if self.product is not None and 'product' not in already_processed:
            already_processed.add('product')
            outfile.write(' product=%s' % (quote_attrib(self.product), ))
        if self.ftype is not None and 'ftype' not in already_processed:
            already_processed.add('ftype')
            outfile.write(' ftype=%s' % (self.gds_format_string(quote_attrib(self.ftype).encode(ExternalEncoding), input_name='ftype'), ))
        if self.mode is not None and 'mode' not in already_processed:
            already_processed.add('mode')
            outfile.write(' mode=%s' % (self.gds_format_string(quote_attrib(self.mode).encode(ExternalEncoding), input_name='mode'), ))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (self.gds_format_string(quote_attrib(self.version).encode(ExternalEncoding), input_name='version'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='analysis', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='analysis'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.sequenceNumber is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            showIndent(outfile, level)
            outfile.write('sequenceNumber="%s",\n' % (self.sequenceNumber,))
        if self.product is not None and 'product' not in already_processed:
            already_processed.add('product')
            showIndent(outfile, level)
            outfile.write('product="%s",\n' % (self.product,))
        if self.ftype is not None and 'ftype' not in already_processed:
            already_processed.add('ftype')
            showIndent(outfile, level)
            outfile.write('ftype="%s",\n' % (self.ftype,))
        if self.mode is not None and 'mode' not in already_processed:
            already_processed.add('mode')
            showIndent(outfile, level)
            outfile.write('mode="%s",\n' % (self.mode,))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            showIndent(outfile, level)
            outfile.write('version="%s",\n' % (self.version,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sequenceNumber', node)
        if value is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            self.sequenceNumber = value
        value = find_attr_value_('product', node)
        if value is not None and 'product' not in already_processed:
            already_processed.add('product')
            self.product = value
            self.validate_ProductTypeShort(self.product)    # validate type ProductTypeShort
        value = find_attr_value_('ftype', node)
        if value is not None and 'ftype' not in already_processed:
            already_processed.add('ftype')
            self.ftype = value
        value = find_attr_value_('mode', node)
        if value is not None and 'mode' not in already_processed:
            already_processed.add('mode')
            self.mode = value
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class analysis


class keyloggerdetected(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, sequenceNumber=None, processinfo=None, idhook=None, hookprocaddr=None, moduleaddr=None, threadid=None, module_name=None, md5sum=None, sha1sum=None, symbol_name=None, symbol_displacement=None):
        self.original_tagname_ = None
        self.sequenceNumber = _cast(None, sequenceNumber)
        self.processinfo = processinfo
        self.idhook = idhook
        self.hookprocaddr = hookprocaddr
        self.moduleaddr = moduleaddr
        self.threadid = threadid
        self.module_name = module_name
        self.md5sum = md5sum
        self.sha1sum = sha1sum
        self.symbol_name = symbol_name
        self.symbol_displacement = symbol_displacement
    def factory(*args_, **kwargs_):
        if keyloggerdetected.subclass:
            return keyloggerdetected.subclass(*args_, **kwargs_)
        else:
            return keyloggerdetected(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_processinfo(self): return self.processinfo
    def set_processinfo(self, processinfo): self.processinfo = processinfo
    def get_idhook(self): return self.idhook
    def set_idhook(self, idhook): self.idhook = idhook
    def get_hookprocaddr(self): return self.hookprocaddr
    def set_hookprocaddr(self, hookprocaddr): self.hookprocaddr = hookprocaddr
    def get_moduleaddr(self): return self.moduleaddr
    def set_moduleaddr(self, moduleaddr): self.moduleaddr = moduleaddr
    def get_threadid(self): return self.threadid
    def set_threadid(self, threadid): self.threadid = threadid
    def get_module_name(self): return self.module_name
    def set_module_name(self, module_name): self.module_name = module_name
    def get_md5sum(self): return self.md5sum
    def set_md5sum(self, md5sum): self.md5sum = md5sum
    def get_sha1sum(self): return self.sha1sum
    def set_sha1sum(self, sha1sum): self.sha1sum = sha1sum
    def get_symbol_name(self): return self.symbol_name
    def set_symbol_name(self, symbol_name): self.symbol_name = symbol_name
    def get_symbol_displacement(self): return self.symbol_displacement
    def set_symbol_displacement(self, symbol_displacement): self.symbol_displacement = symbol_displacement
    def get_sequenceNumber(self): return self.sequenceNumber
    def set_sequenceNumber(self, sequenceNumber): self.sequenceNumber = sequenceNumber
    def hasContent_(self):
        if (
            self.processinfo is not None or
            self.idhook is not None or
            self.hookprocaddr is not None or
            self.moduleaddr is not None or
            self.threadid is not None or
            self.module_name is not None or
            self.md5sum is not None or
            self.sha1sum is not None or
            self.symbol_name is not None or
            self.symbol_displacement is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='keyloggerdetected', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='keyloggerdetected')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='keyloggerdetected', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='keyloggerdetected'):
        if self.sequenceNumber is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            outfile.write(' sequenceNumber=%s' % (self.gds_format_string(quote_attrib(self.sequenceNumber).encode(ExternalEncoding), input_name='sequenceNumber'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='keyloggerdetected', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.processinfo is not None:
            self.processinfo.export(outfile, level, namespace_, name_='processinfo', pretty_print=pretty_print)
        if self.idhook is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sidhook>%s</%sidhook>%s' % (namespace_, self.gds_format_string(quote_xml(self.idhook).encode(ExternalEncoding), input_name='idhook'), namespace_, eol_))
        if self.hookprocaddr is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%shookprocaddr>%s</%shookprocaddr>%s' % (namespace_, self.gds_format_string(quote_xml(self.hookprocaddr).encode(ExternalEncoding), input_name='hookprocaddr'), namespace_, eol_))
        if self.moduleaddr is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smoduleaddr>%s</%smoduleaddr>%s' % (namespace_, self.gds_format_string(quote_xml(self.moduleaddr).encode(ExternalEncoding), input_name='moduleaddr'), namespace_, eol_))
        if self.threadid is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sthreadid>%s</%sthreadid>%s' % (namespace_, self.gds_format_integer(self.threadid, input_name='threadid'), namespace_, eol_))
        if self.module_name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smodule-name>%s</%smodule-name>%s' % (namespace_, self.gds_format_string(quote_xml(self.module_name).encode(ExternalEncoding), input_name='module-name'), namespace_, eol_))
        if self.md5sum is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smd5sum>%s</%smd5sum>%s' % (namespace_, self.gds_format_string(quote_xml(self.md5sum).encode(ExternalEncoding), input_name='md5sum'), namespace_, eol_))
        if self.sha1sum is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssha1sum>%s</%ssha1sum>%s' % (namespace_, self.gds_format_string(quote_xml(self.sha1sum).encode(ExternalEncoding), input_name='sha1sum'), namespace_, eol_))
        if self.symbol_name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssymbol-name>%s</%ssymbol-name>%s' % (namespace_, self.gds_format_string(quote_xml(self.symbol_name).encode(ExternalEncoding), input_name='symbol-name'), namespace_, eol_))
        if self.symbol_displacement is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssymbol-displacement>%s</%ssymbol-displacement>%s' % (namespace_, self.gds_format_string(quote_xml(self.symbol_displacement).encode(ExternalEncoding), input_name='symbol-displacement'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='keyloggerdetected'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.sequenceNumber is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            showIndent(outfile, level)
            outfile.write('sequenceNumber="%s",\n' % (self.sequenceNumber,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.processinfo is not None:
            showIndent(outfile, level)
            outfile.write('processinfo=model_.processinfo(\n')
            self.processinfo.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.idhook is not None:
            showIndent(outfile, level)
            outfile.write('idhook=%s,\n' % quote_python(self.idhook).encode(ExternalEncoding))
        if self.hookprocaddr is not None:
            showIndent(outfile, level)
            outfile.write('hookprocaddr=%s,\n' % quote_python(self.hookprocaddr).encode(ExternalEncoding))
        if self.moduleaddr is not None:
            showIndent(outfile, level)
            outfile.write('moduleaddr=%s,\n' % quote_python(self.moduleaddr).encode(ExternalEncoding))
        if self.threadid is not None:
            showIndent(outfile, level)
            outfile.write('threadid=%d,\n' % self.threadid)
        if self.module_name is not None:
            showIndent(outfile, level)
            outfile.write('module_name=%s,\n' % quote_python(self.module_name).encode(ExternalEncoding))
        if self.md5sum is not None:
            showIndent(outfile, level)
            outfile.write('md5sum=%s,\n' % quote_python(self.md5sum).encode(ExternalEncoding))
        if self.sha1sum is not None:
            showIndent(outfile, level)
            outfile.write('sha1sum=%s,\n' % quote_python(self.sha1sum).encode(ExternalEncoding))
        if self.symbol_name is not None:
            showIndent(outfile, level)
            outfile.write('symbol_name=%s,\n' % quote_python(self.symbol_name).encode(ExternalEncoding))
        if self.symbol_displacement is not None:
            showIndent(outfile, level)
            outfile.write('symbol_displacement=%s,\n' % quote_python(self.symbol_displacement).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sequenceNumber', node)
        if value is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            self.sequenceNumber = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'processinfo':
            obj_ = processinfo.factory()
            obj_.build(child_)
            self.processinfo = obj_
            obj_.original_tagname_ = 'processinfo'
        elif nodeName_ == 'idhook':
            idhook_ = child_.text
            idhook_ = self.gds_validate_string(idhook_, node, 'idhook')
            self.idhook = idhook_
        elif nodeName_ == 'hookprocaddr':
            hookprocaddr_ = child_.text
            hookprocaddr_ = self.gds_validate_string(hookprocaddr_, node, 'hookprocaddr')
            self.hookprocaddr = hookprocaddr_
        elif nodeName_ == 'moduleaddr':
            moduleaddr_ = child_.text
            moduleaddr_ = self.gds_validate_string(moduleaddr_, node, 'moduleaddr')
            self.moduleaddr = moduleaddr_
        elif nodeName_ == 'threadid':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'threadid')
            self.threadid = ival_
        elif nodeName_ == 'module-name':
            module_name_ = child_.text
            module_name_ = self.gds_validate_string(module_name_, node, 'module_name')
            self.module_name = module_name_
        elif nodeName_ == 'md5sum':
            md5sum_ = child_.text
            md5sum_ = self.gds_validate_string(md5sum_, node, 'md5sum')
            self.md5sum = md5sum_
        elif nodeName_ == 'sha1sum':
            sha1sum_ = child_.text
            sha1sum_ = self.gds_validate_string(sha1sum_, node, 'sha1sum')
            self.sha1sum = sha1sum_
        elif nodeName_ == 'symbol-name':
            symbol_name_ = child_.text
            symbol_name_ = self.gds_validate_string(symbol_name_, node, 'symbol_name')
            self.symbol_name = symbol_name_
        elif nodeName_ == 'symbol-displacement':
            symbol_displacement_ = child_.text
            symbol_displacement_ = self.gds_validate_string(symbol_displacement_, node, 'symbol_displacement')
            self.symbol_displacement = symbol_displacement_
# end class keyloggerdetected


class HardwareAccessDetection(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, sequenceNumber=None, processinfo=None, function=None, device=None, handle=None, size=None, address=None):
        self.original_tagname_ = None
        self.sequenceNumber = _cast(None, sequenceNumber)
        self.processinfo = processinfo
        self.function = function
        self.device = device
        self.handle = handle
        self.size = size
        self.address = address
    def factory(*args_, **kwargs_):
        if HardwareAccessDetection.subclass:
            return HardwareAccessDetection.subclass(*args_, **kwargs_)
        else:
            return HardwareAccessDetection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_processinfo(self): return self.processinfo
    def set_processinfo(self, processinfo): self.processinfo = processinfo
    def get_function(self): return self.function
    def set_function(self, function): self.function = function
    def get_device(self): return self.device
    def set_device(self, device): self.device = device
    def get_handle(self): return self.handle
    def set_handle(self, handle): self.handle = handle
    def get_size(self): return self.size
    def set_size(self, size): self.size = size
    def get_address(self): return self.address
    def set_address(self, address): self.address = address
    def get_sequenceNumber(self): return self.sequenceNumber
    def set_sequenceNumber(self, sequenceNumber): self.sequenceNumber = sequenceNumber
    def hasContent_(self):
        if (
            self.processinfo is not None or
            self.function is not None or
            self.device is not None or
            self.handle is not None or
            self.size is not None or
            self.address is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='HardwareAccessDetection', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HardwareAccessDetection')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='HardwareAccessDetection', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='HardwareAccessDetection'):
        if self.sequenceNumber is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            outfile.write(' sequenceNumber=%s' % (self.gds_format_string(quote_attrib(self.sequenceNumber).encode(ExternalEncoding), input_name='sequenceNumber'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='HardwareAccessDetection', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.processinfo is not None:
            self.processinfo.export(outfile, level, namespace_, name_='processinfo', pretty_print=pretty_print)
        if self.function is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfunction>%s</%sfunction>%s' % (namespace_, self.gds_format_string(quote_xml(self.function).encode(ExternalEncoding), input_name='function'), namespace_, eol_))
        if self.device is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdevice>%s</%sdevice>%s' % (namespace_, self.gds_format_string(quote_xml(self.device).encode(ExternalEncoding), input_name='device'), namespace_, eol_))
        if self.handle is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%shandle>%s</%shandle>%s' % (namespace_, self.gds_format_string(quote_xml(self.handle).encode(ExternalEncoding), input_name='handle'), namespace_, eol_))
        if self.size is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssize>%s</%ssize>%s' % (namespace_, self.gds_format_string(quote_xml(self.size).encode(ExternalEncoding), input_name='size'), namespace_, eol_))
        if self.address is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saddress>%s</%saddress>%s' % (namespace_, self.gds_format_string(quote_xml(self.address).encode(ExternalEncoding), input_name='address'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='HardwareAccessDetection'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.sequenceNumber is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            showIndent(outfile, level)
            outfile.write('sequenceNumber="%s",\n' % (self.sequenceNumber,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.processinfo is not None:
            showIndent(outfile, level)
            outfile.write('processinfo=model_.processinfo(\n')
            self.processinfo.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.function is not None:
            showIndent(outfile, level)
            outfile.write('function=%s,\n' % quote_python(self.function).encode(ExternalEncoding))
        if self.device is not None:
            showIndent(outfile, level)
            outfile.write('device=%s,\n' % quote_python(self.device).encode(ExternalEncoding))
        if self.handle is not None:
            showIndent(outfile, level)
            outfile.write('handle=%s,\n' % quote_python(self.handle).encode(ExternalEncoding))
        if self.size is not None:
            showIndent(outfile, level)
            outfile.write('size=%s,\n' % quote_python(self.size).encode(ExternalEncoding))
        if self.address is not None:
            showIndent(outfile, level)
            outfile.write('address=%s,\n' % quote_python(self.address).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sequenceNumber', node)
        if value is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            self.sequenceNumber = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'processinfo':
            obj_ = processinfo.factory()
            obj_.build(child_)
            self.processinfo = obj_
            obj_.original_tagname_ = 'processinfo'
        elif nodeName_ == 'function':
            function_ = child_.text
            function_ = self.gds_validate_string(function_, node, 'function')
            self.function = function_
        elif nodeName_ == 'device':
            device_ = child_.text
            device_ = self.gds_validate_string(device_, node, 'device')
            self.device = device_
        elif nodeName_ == 'handle':
            handle_ = child_.text
            handle_ = self.gds_validate_string(handle_, node, 'handle')
            self.handle = handle_
        elif nodeName_ == 'size':
            size_ = child_.text
            size_ = self.gds_validate_string(size_, node, 'size')
            self.size = size_
        elif nodeName_ == 'address':
            address_ = child_.text
            address_ = self.gds_validate_string(address_, node, 'address')
            self.address = address_
# end class HardwareAccessDetection


class dll_loaded(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, sequenceNumber=None, processinfo=None, dllpath=None, md5sum=None, sha1sum=None):
        self.original_tagname_ = None
        self.sequenceNumber = _cast(None, sequenceNumber)
        self.processinfo = processinfo
        self.dllpath = dllpath
        self.md5sum = md5sum
        self.sha1sum = sha1sum
    def factory(*args_, **kwargs_):
        if dll_loaded.subclass:
            return dll_loaded.subclass(*args_, **kwargs_)
        else:
            return dll_loaded(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_processinfo(self): return self.processinfo
    def set_processinfo(self, processinfo): self.processinfo = processinfo
    def get_dllpath(self): return self.dllpath
    def set_dllpath(self, dllpath): self.dllpath = dllpath
    def get_md5sum(self): return self.md5sum
    def set_md5sum(self, md5sum): self.md5sum = md5sum
    def get_sha1sum(self): return self.sha1sum
    def set_sha1sum(self, sha1sum): self.sha1sum = sha1sum
    def get_sequenceNumber(self): return self.sequenceNumber
    def set_sequenceNumber(self, sequenceNumber): self.sequenceNumber = sequenceNumber
    def hasContent_(self):
        if (
            self.processinfo is not None or
            self.dllpath is not None or
            self.md5sum is not None or
            self.sha1sum is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='dll-loaded', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='dll-loaded')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='dll-loaded', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='dll-loaded'):
        if self.sequenceNumber is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            outfile.write(' sequenceNumber=%s' % (self.gds_format_string(quote_attrib(self.sequenceNumber).encode(ExternalEncoding), input_name='sequenceNumber'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='dll-loaded', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.processinfo is not None:
            self.processinfo.export(outfile, level, namespace_, name_='processinfo', pretty_print=pretty_print)
        if self.dllpath is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdllpath>%s</%sdllpath>%s' % (namespace_, self.gds_format_string(quote_xml(self.dllpath).encode(ExternalEncoding), input_name='dllpath'), namespace_, eol_))
        if self.md5sum is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smd5sum>%s</%smd5sum>%s' % (namespace_, self.gds_format_string(quote_xml(self.md5sum).encode(ExternalEncoding), input_name='md5sum'), namespace_, eol_))
        if self.sha1sum is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssha1sum>%s</%ssha1sum>%s' % (namespace_, self.gds_format_string(quote_xml(self.sha1sum).encode(ExternalEncoding), input_name='sha1sum'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='dll-loaded'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.sequenceNumber is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            showIndent(outfile, level)
            outfile.write('sequenceNumber="%s",\n' % (self.sequenceNumber,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.processinfo is not None:
            showIndent(outfile, level)
            outfile.write('processinfo=model_.processinfo(\n')
            self.processinfo.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.dllpath is not None:
            showIndent(outfile, level)
            outfile.write('dllpath=%s,\n' % quote_python(self.dllpath).encode(ExternalEncoding))
        if self.md5sum is not None:
            showIndent(outfile, level)
            outfile.write('md5sum=%s,\n' % quote_python(self.md5sum).encode(ExternalEncoding))
        if self.sha1sum is not None:
            showIndent(outfile, level)
            outfile.write('sha1sum=%s,\n' % quote_python(self.sha1sum).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sequenceNumber', node)
        if value is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            self.sequenceNumber = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'processinfo':
            obj_ = processinfo.factory()
            obj_.build(child_)
            self.processinfo = obj_
            obj_.original_tagname_ = 'processinfo'
        elif nodeName_ == 'dllpath':
            dllpath_ = child_.text
            dllpath_ = self.gds_validate_string(dllpath_, node, 'dllpath')
            self.dllpath = dllpath_
        elif nodeName_ == 'md5sum':
            md5sum_ = child_.text
            md5sum_ = self.gds_validate_string(md5sum_, node, 'md5sum')
            self.md5sum = md5sum_
        elif nodeName_ == 'sha1sum':
            sha1sum_ = child_.text
            sha1sum_ = self.gds_validate_string(sha1sum_, node, 'sha1sum')
            self.sha1sum = sha1sum_
# end class dll_loaded


class apicall(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, repeat=None, sequenceNumber=None, processinfo=None, dllname=None, apiname=None, address=None, params=None):
        self.original_tagname_ = None
        self.repeat = _cast(int, repeat)
        self.sequenceNumber = _cast(None, sequenceNumber)
        self.processinfo = processinfo
        self.dllname = dllname
        self.apiname = apiname
        self.address = address
        self.params = params
    def factory(*args_, **kwargs_):
        if apicall.subclass:
            return apicall.subclass(*args_, **kwargs_)
        else:
            return apicall(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_processinfo(self): return self.processinfo
    def set_processinfo(self, processinfo): self.processinfo = processinfo
    def get_dllname(self): return self.dllname
    def set_dllname(self, dllname): self.dllname = dllname
    def get_apiname(self): return self.apiname
    def set_apiname(self, apiname): self.apiname = apiname
    def get_address(self): return self.address
    def set_address(self, address): self.address = address
    def get_params(self): return self.params
    def set_params(self, params): self.params = params
    def get_repeat(self): return self.repeat
    def set_repeat(self, repeat): self.repeat = repeat
    def get_sequenceNumber(self): return self.sequenceNumber
    def set_sequenceNumber(self, sequenceNumber): self.sequenceNumber = sequenceNumber
    def hasContent_(self):
        if (
            self.processinfo is not None or
            self.dllname is not None or
            self.apiname is not None or
            self.address is not None or
            self.params is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='apicall', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='apicall')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='apicall', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='apicall'):
        if self.repeat is not None and 'repeat' not in already_processed:
            already_processed.add('repeat')
            outfile.write(' repeat="%s"' % self.gds_format_integer(self.repeat, input_name='repeat'))
        if self.sequenceNumber is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            outfile.write(' sequenceNumber=%s' % (self.gds_format_string(quote_attrib(self.sequenceNumber).encode(ExternalEncoding), input_name='sequenceNumber'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='apicall', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.processinfo is not None:
            self.processinfo.export(outfile, level, namespace_, name_='processinfo', pretty_print=pretty_print)
        if self.dllname is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdllname>%s</%sdllname>%s' % (namespace_, self.gds_format_string(quote_xml(self.dllname).encode(ExternalEncoding), input_name='dllname'), namespace_, eol_))
        if self.apiname is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sapiname>%s</%sapiname>%s' % (namespace_, self.gds_format_string(quote_xml(self.apiname).encode(ExternalEncoding), input_name='apiname'), namespace_, eol_))
        if self.address is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saddress>%s</%saddress>%s' % (namespace_, self.gds_format_string(quote_xml(self.address).encode(ExternalEncoding), input_name='address'), namespace_, eol_))
        if self.params is not None:
            self.params.export(outfile, level, namespace_, name_='params', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='apicall'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.repeat is not None and 'repeat' not in already_processed:
            already_processed.add('repeat')
            showIndent(outfile, level)
            outfile.write('repeat=%d,\n' % (self.repeat,))
        if self.sequenceNumber is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            showIndent(outfile, level)
            outfile.write('sequenceNumber="%s",\n' % (self.sequenceNumber,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.processinfo is not None:
            showIndent(outfile, level)
            outfile.write('processinfo=model_.processinfo(\n')
            self.processinfo.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.dllname is not None:
            showIndent(outfile, level)
            outfile.write('dllname=%s,\n' % quote_python(self.dllname).encode(ExternalEncoding))
        if self.apiname is not None:
            showIndent(outfile, level)
            outfile.write('apiname=%s,\n' % quote_python(self.apiname).encode(ExternalEncoding))
        if self.address is not None:
            showIndent(outfile, level)
            outfile.write('address=%s,\n' % quote_python(self.address).encode(ExternalEncoding))
        if self.params is not None:
            showIndent(outfile, level)
            outfile.write('params=model_.params(\n')
            self.params.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('repeat', node)
        if value is not None and 'repeat' not in already_processed:
            already_processed.add('repeat')
            try:
                self.repeat = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('sequenceNumber', node)
        if value is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            self.sequenceNumber = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'processinfo':
            obj_ = processinfo.factory()
            obj_.build(child_)
            self.processinfo = obj_
            obj_.original_tagname_ = 'processinfo'
        elif nodeName_ == 'dllname':
            dllname_ = child_.text
            dllname_ = self.gds_validate_string(dllname_, node, 'dllname')
            self.dllname = dllname_
        elif nodeName_ == 'apiname':
            apiname_ = child_.text
            apiname_ = self.gds_validate_string(apiname_, node, 'apiname')
            self.apiname = apiname_
        elif nodeName_ == 'address':
            address_ = child_.text
            address_ = self.gds_validate_string(address_, node, 'address')
            self.address = address_
        elif nodeName_ == 'params':
            obj_ = params.factory()
            obj_.build(child_)
            self.params = obj_
            obj_.original_tagname_ = 'params'
# end class apicall


class codeinjection(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, mode=None, sequenceNumber=None, source=None, target=None):
        self.original_tagname_ = None
        self.mode = _cast(None, mode)
        self.sequenceNumber = _cast(None, sequenceNumber)
        self.source = source
        self.target = target
    def factory(*args_, **kwargs_):
        if codeinjection.subclass:
            return codeinjection.subclass(*args_, **kwargs_)
        else:
            return codeinjection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_source(self): return self.source
    def set_source(self, source): self.source = source
    def get_target(self): return self.target
    def set_target(self, target): self.target = target
    def get_mode(self): return self.mode
    def set_mode(self, mode): self.mode = mode
    def get_sequenceNumber(self): return self.sequenceNumber
    def set_sequenceNumber(self, sequenceNumber): self.sequenceNumber = sequenceNumber
    def hasContent_(self):
        if (
            self.source is not None or
            self.target is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='codeinjection', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='codeinjection')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='codeinjection', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='codeinjection'):
        if self.mode is not None and 'mode' not in already_processed:
            already_processed.add('mode')
            outfile.write(' mode=%s' % (self.gds_format_string(quote_attrib(self.mode).encode(ExternalEncoding), input_name='mode'), ))
        if self.sequenceNumber is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            outfile.write(' sequenceNumber=%s' % (self.gds_format_string(quote_attrib(self.sequenceNumber).encode(ExternalEncoding), input_name='sequenceNumber'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='codeinjection', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.source is not None:
            self.source.export(outfile, level, namespace_, name_='source', pretty_print=pretty_print)
        if self.target is not None:
            self.target.export(outfile, level, namespace_, name_='target', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='codeinjection'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.mode is not None and 'mode' not in already_processed:
            already_processed.add('mode')
            showIndent(outfile, level)
            outfile.write('mode="%s",\n' % (self.mode,))
        if self.sequenceNumber is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            showIndent(outfile, level)
            outfile.write('sequenceNumber="%s",\n' % (self.sequenceNumber,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.source is not None:
            showIndent(outfile, level)
            outfile.write('source=model_.source(\n')
            self.source.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.target is not None:
            showIndent(outfile, level)
            outfile.write('target=model_.target(\n')
            self.target.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('mode', node)
        if value is not None and 'mode' not in already_processed:
            already_processed.add('mode')
            self.mode = value
        value = find_attr_value_('sequenceNumber', node)
        if value is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            self.sequenceNumber = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'source':
            obj_ = source.factory()
            obj_.build(child_)
            self.source = obj_
            obj_.original_tagname_ = 'source'
        elif nodeName_ == 'target':
            obj_ = target.factory()
            obj_.build(child_)
            self.target = obj_
            obj_.original_tagname_ = 'target'
# end class codeinjection


class source(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, sequenceNumber=None, processinfo=None):
        self.original_tagname_ = None
        self.sequenceNumber = _cast(None, sequenceNumber)
        self.processinfo = processinfo
    def factory(*args_, **kwargs_):
        if source.subclass:
            return source.subclass(*args_, **kwargs_)
        else:
            return source(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_processinfo(self): return self.processinfo
    def set_processinfo(self, processinfo): self.processinfo = processinfo
    def get_sequenceNumber(self): return self.sequenceNumber
    def set_sequenceNumber(self, sequenceNumber): self.sequenceNumber = sequenceNumber
    def hasContent_(self):
        if (
            self.processinfo is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='source', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='source')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='source', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='source'):
        if self.sequenceNumber is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            outfile.write(' sequenceNumber=%s' % (self.gds_format_string(quote_attrib(self.sequenceNumber).encode(ExternalEncoding), input_name='sequenceNumber'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='source', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.processinfo is not None:
            self.processinfo.export(outfile, level, namespace_, name_='processinfo', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='source'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.sequenceNumber is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            showIndent(outfile, level)
            outfile.write('sequenceNumber="%s",\n' % (self.sequenceNumber,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.processinfo is not None:
            showIndent(outfile, level)
            outfile.write('processinfo=model_.processinfo(\n')
            self.processinfo.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sequenceNumber', node)
        if value is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            self.sequenceNumber = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'processinfo':
            obj_ = processinfo.factory()
            obj_.build(child_)
            self.processinfo = obj_
            obj_.original_tagname_ = 'processinfo'
# end class source


class target(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, sequenceNumber=None, processinfo=None):
        self.original_tagname_ = None
        self.sequenceNumber = _cast(None, sequenceNumber)
        self.processinfo = processinfo
    def factory(*args_, **kwargs_):
        if target.subclass:
            return target.subclass(*args_, **kwargs_)
        else:
            return target(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_processinfo(self): return self.processinfo
    def set_processinfo(self, processinfo): self.processinfo = processinfo
    def get_sequenceNumber(self): return self.sequenceNumber
    def set_sequenceNumber(self, sequenceNumber): self.sequenceNumber = sequenceNumber
    def hasContent_(self):
        if (
            self.processinfo is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='target', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='target')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='target', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='target'):
        if self.sequenceNumber is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            outfile.write(' sequenceNumber=%s' % (self.gds_format_string(quote_attrib(self.sequenceNumber).encode(ExternalEncoding), input_name='sequenceNumber'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='target', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.processinfo is not None:
            self.processinfo.export(outfile, level, namespace_, name_='processinfo', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='target'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.sequenceNumber is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            showIndent(outfile, level)
            outfile.write('sequenceNumber="%s",\n' % (self.sequenceNumber,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.processinfo is not None:
            showIndent(outfile, level)
            outfile.write('processinfo=model_.processinfo(\n')
            self.processinfo.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sequenceNumber', node)
        if value is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            self.sequenceNumber = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'processinfo':
            obj_ = processinfo.factory()
            obj_.build(child_)
            self.processinfo = obj_
            obj_.original_tagname_ = 'processinfo'
# end class target


class driver(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, mode=None, sequenceNumber=None, processinfo=None, registrypath=None, driverimage=None, method=None):
        self.original_tagname_ = None
        self.mode = _cast(None, mode)
        self.sequenceNumber = _cast(None, sequenceNumber)
        self.processinfo = processinfo
        self.registrypath = registrypath
        self.driverimage = driverimage
        self.method = method
    def factory(*args_, **kwargs_):
        if driver.subclass:
            return driver.subclass(*args_, **kwargs_)
        else:
            return driver(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_processinfo(self): return self.processinfo
    def set_processinfo(self, processinfo): self.processinfo = processinfo
    def get_registrypath(self): return self.registrypath
    def set_registrypath(self, registrypath): self.registrypath = registrypath
    def get_driverimage(self): return self.driverimage
    def set_driverimage(self, driverimage): self.driverimage = driverimage
    def get_method(self): return self.method
    def set_method(self, method): self.method = method
    def get_mode(self): return self.mode
    def set_mode(self, mode): self.mode = mode
    def get_sequenceNumber(self): return self.sequenceNumber
    def set_sequenceNumber(self, sequenceNumber): self.sequenceNumber = sequenceNumber
    def hasContent_(self):
        if (
            self.processinfo is not None or
            self.registrypath is not None or
            self.driverimage is not None or
            self.method is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='driver', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='driver')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='driver', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='driver'):
        if self.mode is not None and 'mode' not in already_processed:
            already_processed.add('mode')
            outfile.write(' mode=%s' % (self.gds_format_string(quote_attrib(self.mode).encode(ExternalEncoding), input_name='mode'), ))
        if self.sequenceNumber is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            outfile.write(' sequenceNumber=%s' % (self.gds_format_string(quote_attrib(self.sequenceNumber).encode(ExternalEncoding), input_name='sequenceNumber'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='driver', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.processinfo is not None:
            self.processinfo.export(outfile, level, namespace_, name_='processinfo', pretty_print=pretty_print)
        if self.registrypath is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sregistrypath>%s</%sregistrypath>%s' % (namespace_, self.gds_format_string(quote_xml(self.registrypath).encode(ExternalEncoding), input_name='registrypath'), namespace_, eol_))
        if self.driverimage is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdriverimage>%s</%sdriverimage>%s' % (namespace_, self.gds_format_string(quote_xml(self.driverimage).encode(ExternalEncoding), input_name='driverimage'), namespace_, eol_))
        if self.method is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smethod>%s</%smethod>%s' % (namespace_, self.gds_format_string(quote_xml(self.method).encode(ExternalEncoding), input_name='method'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='driver'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.mode is not None and 'mode' not in already_processed:
            already_processed.add('mode')
            showIndent(outfile, level)
            outfile.write('mode="%s",\n' % (self.mode,))
        if self.sequenceNumber is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            showIndent(outfile, level)
            outfile.write('sequenceNumber="%s",\n' % (self.sequenceNumber,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.processinfo is not None:
            showIndent(outfile, level)
            outfile.write('processinfo=model_.processinfo(\n')
            self.processinfo.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.registrypath is not None:
            showIndent(outfile, level)
            outfile.write('registrypath=%s,\n' % quote_python(self.registrypath).encode(ExternalEncoding))
        if self.driverimage is not None:
            showIndent(outfile, level)
            outfile.write('driverimage=%s,\n' % quote_python(self.driverimage).encode(ExternalEncoding))
        if self.method is not None:
            showIndent(outfile, level)
            outfile.write('method=%s,\n' % quote_python(self.method).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('mode', node)
        if value is not None and 'mode' not in already_processed:
            already_processed.add('mode')
            self.mode = value
        value = find_attr_value_('sequenceNumber', node)
        if value is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            self.sequenceNumber = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'processinfo':
            obj_ = processinfo.factory()
            obj_.build(child_)
            self.processinfo = obj_
            obj_.original_tagname_ = 'processinfo'
        elif nodeName_ == 'registrypath':
            registrypath_ = child_.text
            registrypath_ = self.gds_validate_string(registrypath_, node, 'registrypath')
            self.registrypath = registrypath_
        elif nodeName_ == 'driverimage':
            driverimage_ = child_.text
            driverimage_ = self.gds_validate_string(driverimage_, node, 'driverimage')
            self.driverimage = driverimage_
        elif nodeName_ == 'method':
            method_ = child_.text
            method_ = self.gds_validate_string(method_, node, 'method')
            self.method = method_
# end class driver


class exploitcode(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, sequenceNumber=None, processinfo=None, dllname=None, apiname=None, address=None, params=None, callstack=None):
        self.original_tagname_ = None
        self.sequenceNumber = _cast(None, sequenceNumber)
        self.processinfo = processinfo
        self.dllname = dllname
        self.apiname = apiname
        self.address = address
        self.params = params
        self.callstack = callstack
    def factory(*args_, **kwargs_):
        if exploitcode.subclass:
            return exploitcode.subclass(*args_, **kwargs_)
        else:
            return exploitcode(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_processinfo(self): return self.processinfo
    def set_processinfo(self, processinfo): self.processinfo = processinfo
    def get_dllname(self): return self.dllname
    def set_dllname(self, dllname): self.dllname = dllname
    def get_apiname(self): return self.apiname
    def set_apiname(self, apiname): self.apiname = apiname
    def get_address(self): return self.address
    def set_address(self, address): self.address = address
    def get_params(self): return self.params
    def set_params(self, params): self.params = params
    def get_callstack(self): return self.callstack
    def set_callstack(self, callstack): self.callstack = callstack
    def get_sequenceNumber(self): return self.sequenceNumber
    def set_sequenceNumber(self, sequenceNumber): self.sequenceNumber = sequenceNumber
    def hasContent_(self):
        if (
            self.processinfo is not None or
            self.dllname is not None or
            self.apiname is not None or
            self.address is not None or
            self.params is not None or
            self.callstack is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='exploitcode', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='exploitcode')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='exploitcode', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='exploitcode'):
        if self.sequenceNumber is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            outfile.write(' sequenceNumber=%s' % (self.gds_format_string(quote_attrib(self.sequenceNumber).encode(ExternalEncoding), input_name='sequenceNumber'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='exploitcode', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.processinfo is not None:
            self.processinfo.export(outfile, level, namespace_, name_='processinfo', pretty_print=pretty_print)
        if self.dllname is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdllname>%s</%sdllname>%s' % (namespace_, self.gds_format_string(quote_xml(self.dllname).encode(ExternalEncoding), input_name='dllname'), namespace_, eol_))
        if self.apiname is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sapiname>%s</%sapiname>%s' % (namespace_, self.gds_format_string(quote_xml(self.apiname).encode(ExternalEncoding), input_name='apiname'), namespace_, eol_))
        if self.address is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saddress>%s</%saddress>%s' % (namespace_, self.gds_format_string(quote_xml(self.address).encode(ExternalEncoding), input_name='address'), namespace_, eol_))
        if self.params is not None:
            self.params.export(outfile, level, namespace_, name_='params', pretty_print=pretty_print)
        if self.callstack is not None:
            self.callstack.export(outfile, level, namespace_, name_='callstack', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='exploitcode'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.sequenceNumber is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            showIndent(outfile, level)
            outfile.write('sequenceNumber="%s",\n' % (self.sequenceNumber,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.processinfo is not None:
            showIndent(outfile, level)
            outfile.write('processinfo=model_.processinfo(\n')
            self.processinfo.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.dllname is not None:
            showIndent(outfile, level)
            outfile.write('dllname=%s,\n' % quote_python(self.dllname).encode(ExternalEncoding))
        if self.apiname is not None:
            showIndent(outfile, level)
            outfile.write('apiname=%s,\n' % quote_python(self.apiname).encode(ExternalEncoding))
        if self.address is not None:
            showIndent(outfile, level)
            outfile.write('address=%s,\n' % quote_python(self.address).encode(ExternalEncoding))
        if self.params is not None:
            showIndent(outfile, level)
            outfile.write('params=model_.params(\n')
            self.params.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.callstack is not None:
            showIndent(outfile, level)
            outfile.write('callstack=model_.callstack(\n')
            self.callstack.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sequenceNumber', node)
        if value is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            self.sequenceNumber = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'processinfo':
            obj_ = processinfo.factory()
            obj_.build(child_)
            self.processinfo = obj_
            obj_.original_tagname_ = 'processinfo'
        elif nodeName_ == 'dllname':
            dllname_ = child_.text
            dllname_ = self.gds_validate_string(dllname_, node, 'dllname')
            self.dllname = dllname_
        elif nodeName_ == 'apiname':
            apiname_ = child_.text
            apiname_ = self.gds_validate_string(apiname_, node, 'apiname')
            self.apiname = apiname_
        elif nodeName_ == 'address':
            address_ = child_.text
            address_ = self.gds_validate_string(address_, node, 'address')
            self.address = address_
        elif nodeName_ == 'params':
            obj_ = params.factory()
            obj_.build(child_)
            self.params = obj_
            obj_.original_tagname_ = 'params'
        elif nodeName_ == 'callstack':
            obj_ = callstack.factory()
            obj_.build(child_)
            self.callstack = obj_
            obj_.original_tagname_ = 'callstack'
# end class exploitcode


class file(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, type_=None, mode=None, sequenceNumber=None, value=None, filesize=None, md5sum=None, sha1sum=None, target=None, processinfo=None, old_name=None, new_name=None, creationTime=None, lastWriteTime=None, changeTime=None, newCreationTime=None, newLastWriteTime=None, newChangeTime=None, fid=None):
        self.original_tagname_ = None
        self.type_ = _cast(None, type_)
        self.mode = _cast(None, mode)
        self.sequenceNumber = _cast(None, sequenceNumber)
        self.value = value
        self.filesize = filesize
        self.md5sum = md5sum
        self.sha1sum = sha1sum
        self.target = target
        self.processinfo = processinfo
        self.old_name = old_name
        self.new_name = new_name
        self.creationTime = creationTime
        self.lastWriteTime = lastWriteTime
        self.changeTime = changeTime
        self.newCreationTime = newCreationTime
        self.newLastWriteTime = newLastWriteTime
        self.newChangeTime = newChangeTime
        self.fid = fid
    def factory(*args_, **kwargs_):
        if file.subclass:
            return file.subclass(*args_, **kwargs_)
        else:
            return file(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_filesize(self): return self.filesize
    def set_filesize(self, filesize): self.filesize = filesize
    def get_md5sum(self): return self.md5sum
    def set_md5sum(self, md5sum): self.md5sum = md5sum
    def get_sha1sum(self): return self.sha1sum
    def set_sha1sum(self, sha1sum): self.sha1sum = sha1sum
    def get_target(self): return self.target
    def set_target(self, target): self.target = target
    def get_processinfo(self): return self.processinfo
    def set_processinfo(self, processinfo): self.processinfo = processinfo
    def get_old_name(self): return self.old_name
    def set_old_name(self, old_name): self.old_name = old_name
    def get_new_name(self): return self.new_name
    def set_new_name(self, new_name): self.new_name = new_name
    def get_creationTime(self): return self.creationTime
    def set_creationTime(self, creationTime): self.creationTime = creationTime
    def get_lastWriteTime(self): return self.lastWriteTime
    def set_lastWriteTime(self, lastWriteTime): self.lastWriteTime = lastWriteTime
    def get_changeTime(self): return self.changeTime
    def set_changeTime(self, changeTime): self.changeTime = changeTime
    def get_newCreationTime(self): return self.newCreationTime
    def set_newCreationTime(self, newCreationTime): self.newCreationTime = newCreationTime
    def get_newLastWriteTime(self): return self.newLastWriteTime
    def set_newLastWriteTime(self, newLastWriteTime): self.newLastWriteTime = newLastWriteTime
    def get_newChangeTime(self): return self.newChangeTime
    def set_newChangeTime(self, newChangeTime): self.newChangeTime = newChangeTime
    def get_fid(self): return self.fid
    def set_fid(self, fid): self.fid = fid
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_mode(self): return self.mode
    def set_mode(self, mode): self.mode = mode
    def get_sequenceNumber(self): return self.sequenceNumber
    def set_sequenceNumber(self, sequenceNumber): self.sequenceNumber = sequenceNumber
    def hasContent_(self):
        if (
            self.value is not None or
            self.filesize is not None or
            self.md5sum is not None or
            self.sha1sum is not None or
            self.target is not None or
            self.processinfo is not None or
            self.old_name is not None or
            self.new_name is not None or
            self.creationTime is not None or
            self.lastWriteTime is not None or
            self.changeTime is not None or
            self.newCreationTime is not None or
            self.newLastWriteTime is not None or
            self.newChangeTime is not None or
            self.fid is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='file', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='file')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='file', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='file'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        if self.mode is not None and 'mode' not in already_processed:
            already_processed.add('mode')
            outfile.write(' mode=%s' % (self.gds_format_string(quote_attrib(self.mode).encode(ExternalEncoding), input_name='mode'), ))
        if self.sequenceNumber is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            outfile.write(' sequenceNumber=%s' % (self.gds_format_string(quote_attrib(self.sequenceNumber).encode(ExternalEncoding), input_name='sequenceNumber'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='file', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_string(quote_xml(self.value).encode(ExternalEncoding), input_name='value'), namespace_, eol_))
        if self.filesize is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfilesize>%s</%sfilesize>%s' % (namespace_, self.gds_format_string(quote_xml(self.filesize).encode(ExternalEncoding), input_name='filesize'), namespace_, eol_))
        if self.md5sum is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smd5sum>%s</%smd5sum>%s' % (namespace_, self.gds_format_string(quote_xml(self.md5sum).encode(ExternalEncoding), input_name='md5sum'), namespace_, eol_))
        if self.sha1sum is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssha1sum>%s</%ssha1sum>%s' % (namespace_, self.gds_format_string(quote_xml(self.sha1sum).encode(ExternalEncoding), input_name='sha1sum'), namespace_, eol_))
        if self.target is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%starget>%s</%starget>%s' % (namespace_, self.gds_format_string(quote_xml(self.target).encode(ExternalEncoding), input_name='target'), namespace_, eol_))
        if self.processinfo is not None:
            self.processinfo.export(outfile, level, namespace_, name_='processinfo', pretty_print=pretty_print)
        if self.old_name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sold_name>%s</%sold_name>%s' % (namespace_, self.gds_format_string(quote_xml(self.old_name).encode(ExternalEncoding), input_name='old_name'), namespace_, eol_))
        if self.new_name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snew_name>%s</%snew_name>%s' % (namespace_, self.gds_format_string(quote_xml(self.new_name).encode(ExternalEncoding), input_name='new_name'), namespace_, eol_))
        if self.creationTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%screationTime>%s</%screationTime>%s' % (namespace_, self.gds_format_string(quote_xml(self.creationTime).encode(ExternalEncoding), input_name='creationTime'), namespace_, eol_))
        if self.lastWriteTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slastWriteTime>%s</%slastWriteTime>%s' % (namespace_, self.gds_format_string(quote_xml(self.lastWriteTime).encode(ExternalEncoding), input_name='lastWriteTime'), namespace_, eol_))
        if self.changeTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%schangeTime>%s</%schangeTime>%s' % (namespace_, self.gds_format_string(quote_xml(self.changeTime).encode(ExternalEncoding), input_name='changeTime'), namespace_, eol_))
        if self.newCreationTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snewCreationTime>%s</%snewCreationTime>%s' % (namespace_, self.gds_format_string(quote_xml(self.newCreationTime).encode(ExternalEncoding), input_name='newCreationTime'), namespace_, eol_))
        if self.newLastWriteTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snewLastWriteTime>%s</%snewLastWriteTime>%s' % (namespace_, self.gds_format_string(quote_xml(self.newLastWriteTime).encode(ExternalEncoding), input_name='newLastWriteTime'), namespace_, eol_))
        if self.newChangeTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snewChangeTime>%s</%snewChangeTime>%s' % (namespace_, self.gds_format_string(quote_xml(self.newChangeTime).encode(ExternalEncoding), input_name='newChangeTime'), namespace_, eol_))
        if self.fid is not None:
            self.fid.export(outfile, level, namespace_, name_='fid', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='file'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
        if self.mode is not None and 'mode' not in already_processed:
            already_processed.add('mode')
            showIndent(outfile, level)
            outfile.write('mode="%s",\n' % (self.mode,))
        if self.sequenceNumber is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            showIndent(outfile, level)
            outfile.write('sequenceNumber="%s",\n' % (self.sequenceNumber,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=%s,\n' % quote_python(self.value).encode(ExternalEncoding))
        if self.filesize is not None:
            showIndent(outfile, level)
            outfile.write('filesize=%s,\n' % quote_python(self.filesize).encode(ExternalEncoding))
        if self.md5sum is not None:
            showIndent(outfile, level)
            outfile.write('md5sum=%s,\n' % quote_python(self.md5sum).encode(ExternalEncoding))
        if self.sha1sum is not None:
            showIndent(outfile, level)
            outfile.write('sha1sum=%s,\n' % quote_python(self.sha1sum).encode(ExternalEncoding))
        if self.target is not None:
            showIndent(outfile, level)
            outfile.write('target=%s,\n' % quote_python(self.target).encode(ExternalEncoding))
        if self.processinfo is not None:
            showIndent(outfile, level)
            outfile.write('processinfo=model_.processinfo(\n')
            self.processinfo.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.old_name is not None:
            showIndent(outfile, level)
            outfile.write('old_name=%s,\n' % quote_python(self.old_name).encode(ExternalEncoding))
        if self.new_name is not None:
            showIndent(outfile, level)
            outfile.write('new_name=%s,\n' % quote_python(self.new_name).encode(ExternalEncoding))
        if self.creationTime is not None:
            showIndent(outfile, level)
            outfile.write('creationTime=%s,\n' % quote_python(self.creationTime).encode(ExternalEncoding))
        if self.lastWriteTime is not None:
            showIndent(outfile, level)
            outfile.write('lastWriteTime=%s,\n' % quote_python(self.lastWriteTime).encode(ExternalEncoding))
        if self.changeTime is not None:
            showIndent(outfile, level)
            outfile.write('changeTime=%s,\n' % quote_python(self.changeTime).encode(ExternalEncoding))
        if self.newCreationTime is not None:
            showIndent(outfile, level)
            outfile.write('newCreationTime=%s,\n' % quote_python(self.newCreationTime).encode(ExternalEncoding))
        if self.newLastWriteTime is not None:
            showIndent(outfile, level)
            outfile.write('newLastWriteTime=%s,\n' % quote_python(self.newLastWriteTime).encode(ExternalEncoding))
        if self.newChangeTime is not None:
            showIndent(outfile, level)
            outfile.write('newChangeTime=%s,\n' % quote_python(self.newChangeTime).encode(ExternalEncoding))
        if self.fid is not None:
            showIndent(outfile, level)
            outfile.write('fid=model_.fid(\n')
            self.fid.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('mode', node)
        if value is not None and 'mode' not in already_processed:
            already_processed.add('mode')
            self.mode = value
        value = find_attr_value_('sequenceNumber', node)
        if value is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            self.sequenceNumber = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value = value_
        elif nodeName_ == 'filesize':
            filesize_ = child_.text
            filesize_ = self.gds_validate_string(filesize_, node, 'filesize')
            self.filesize = filesize_
        elif nodeName_ == 'md5sum':
            md5sum_ = child_.text
            md5sum_ = self.gds_validate_string(md5sum_, node, 'md5sum')
            self.md5sum = md5sum_
        elif nodeName_ == 'sha1sum':
            sha1sum_ = child_.text
            sha1sum_ = self.gds_validate_string(sha1sum_, node, 'sha1sum')
            self.sha1sum = sha1sum_
        elif nodeName_ == 'target':
            target_ = child_.text
            target_ = self.gds_validate_string(target_, node, 'target')
            self.target = target_
        elif nodeName_ == 'processinfo':
            obj_ = processinfo.factory()
            obj_.build(child_)
            self.processinfo = obj_
            obj_.original_tagname_ = 'processinfo'
        elif nodeName_ == 'old_name':
            old_name_ = child_.text
            old_name_ = self.gds_validate_string(old_name_, node, 'old_name')
            self.old_name = old_name_
        elif nodeName_ == 'new_name':
            new_name_ = child_.text
            new_name_ = self.gds_validate_string(new_name_, node, 'new_name')
            self.new_name = new_name_
        elif nodeName_ == 'creationTime':
            creationTime_ = child_.text
            creationTime_ = self.gds_validate_string(creationTime_, node, 'creationTime')
            self.creationTime = creationTime_
        elif nodeName_ == 'lastWriteTime':
            lastWriteTime_ = child_.text
            lastWriteTime_ = self.gds_validate_string(lastWriteTime_, node, 'lastWriteTime')
            self.lastWriteTime = lastWriteTime_
        elif nodeName_ == 'changeTime':
            changeTime_ = child_.text
            changeTime_ = self.gds_validate_string(changeTime_, node, 'changeTime')
            self.changeTime = changeTime_
        elif nodeName_ == 'newCreationTime':
            newCreationTime_ = child_.text
            newCreationTime_ = self.gds_validate_string(newCreationTime_, node, 'newCreationTime')
            self.newCreationTime = newCreationTime_
        elif nodeName_ == 'newLastWriteTime':
            newLastWriteTime_ = child_.text
            newLastWriteTime_ = self.gds_validate_string(newLastWriteTime_, node, 'newLastWriteTime')
            self.newLastWriteTime = newLastWriteTime_
        elif nodeName_ == 'newChangeTime':
            newChangeTime_ = child_.text
            newChangeTime_ = self.gds_validate_string(newChangeTime_, node, 'newChangeTime')
            self.newChangeTime = newChangeTime_
        elif nodeName_ == 'fid':
            obj_ = fid.factory()
            obj_.build(child_)
            self.fid = obj_
            obj_.original_tagname_ = 'fid'
# end class file


class folder(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, mode=None, sequenceNumber=None, value=None, old_name=None, new_name=None, creationTime=None, lastWriteTime=None, changeTime=None, newCreationTime=None, newLastWriteTime=None, newChangeTime=None, processinfo=None):
        self.original_tagname_ = None
        self.mode = _cast(None, mode)
        self.sequenceNumber = _cast(None, sequenceNumber)
        self.value = value
        self.old_name = old_name
        self.new_name = new_name
        self.creationTime = creationTime
        self.lastWriteTime = lastWriteTime
        self.changeTime = changeTime
        self.newCreationTime = newCreationTime
        self.newLastWriteTime = newLastWriteTime
        self.newChangeTime = newChangeTime
        self.processinfo = processinfo
    def factory(*args_, **kwargs_):
        if folder.subclass:
            return folder.subclass(*args_, **kwargs_)
        else:
            return folder(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_old_name(self): return self.old_name
    def set_old_name(self, old_name): self.old_name = old_name
    def get_new_name(self): return self.new_name
    def set_new_name(self, new_name): self.new_name = new_name
    def get_creationTime(self): return self.creationTime
    def set_creationTime(self, creationTime): self.creationTime = creationTime
    def get_lastWriteTime(self): return self.lastWriteTime
    def set_lastWriteTime(self, lastWriteTime): self.lastWriteTime = lastWriteTime
    def get_changeTime(self): return self.changeTime
    def set_changeTime(self, changeTime): self.changeTime = changeTime
    def get_newCreationTime(self): return self.newCreationTime
    def set_newCreationTime(self, newCreationTime): self.newCreationTime = newCreationTime
    def get_newLastWriteTime(self): return self.newLastWriteTime
    def set_newLastWriteTime(self, newLastWriteTime): self.newLastWriteTime = newLastWriteTime
    def get_newChangeTime(self): return self.newChangeTime
    def set_newChangeTime(self, newChangeTime): self.newChangeTime = newChangeTime
    def get_processinfo(self): return self.processinfo
    def set_processinfo(self, processinfo): self.processinfo = processinfo
    def get_mode(self): return self.mode
    def set_mode(self, mode): self.mode = mode
    def get_sequenceNumber(self): return self.sequenceNumber
    def set_sequenceNumber(self, sequenceNumber): self.sequenceNumber = sequenceNumber
    def hasContent_(self):
        if (
            self.value is not None or
            self.old_name is not None or
            self.new_name is not None or
            self.creationTime is not None or
            self.lastWriteTime is not None or
            self.changeTime is not None or
            self.newCreationTime is not None or
            self.newLastWriteTime is not None or
            self.newChangeTime is not None or
            self.processinfo is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='folder', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='folder')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='folder', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='folder'):
        if self.mode is not None and 'mode' not in already_processed:
            already_processed.add('mode')
            outfile.write(' mode=%s' % (self.gds_format_string(quote_attrib(self.mode).encode(ExternalEncoding), input_name='mode'), ))
        if self.sequenceNumber is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            outfile.write(' sequenceNumber=%s' % (self.gds_format_string(quote_attrib(self.sequenceNumber).encode(ExternalEncoding), input_name='sequenceNumber'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='folder', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_string(quote_xml(self.value).encode(ExternalEncoding), input_name='value'), namespace_, eol_))
        if self.old_name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sold_name>%s</%sold_name>%s' % (namespace_, self.gds_format_string(quote_xml(self.old_name).encode(ExternalEncoding), input_name='old_name'), namespace_, eol_))
        if self.new_name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snew_name>%s</%snew_name>%s' % (namespace_, self.gds_format_string(quote_xml(self.new_name).encode(ExternalEncoding), input_name='new_name'), namespace_, eol_))
        if self.creationTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%screationTime>%s</%screationTime>%s' % (namespace_, self.gds_format_string(quote_xml(self.creationTime).encode(ExternalEncoding), input_name='creationTime'), namespace_, eol_))
        if self.lastWriteTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slastWriteTime>%s</%slastWriteTime>%s' % (namespace_, self.gds_format_string(quote_xml(self.lastWriteTime).encode(ExternalEncoding), input_name='lastWriteTime'), namespace_, eol_))
        if self.changeTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%schangeTime>%s</%schangeTime>%s' % (namespace_, self.gds_format_string(quote_xml(self.changeTime).encode(ExternalEncoding), input_name='changeTime'), namespace_, eol_))
        if self.newCreationTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snewCreationTime>%s</%snewCreationTime>%s' % (namespace_, self.gds_format_string(quote_xml(self.newCreationTime).encode(ExternalEncoding), input_name='newCreationTime'), namespace_, eol_))
        if self.newLastWriteTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snewLastWriteTime>%s</%snewLastWriteTime>%s' % (namespace_, self.gds_format_string(quote_xml(self.newLastWriteTime).encode(ExternalEncoding), input_name='newLastWriteTime'), namespace_, eol_))
        if self.newChangeTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snewChangeTime>%s</%snewChangeTime>%s' % (namespace_, self.gds_format_string(quote_xml(self.newChangeTime).encode(ExternalEncoding), input_name='newChangeTime'), namespace_, eol_))
        if self.processinfo is not None:
            self.processinfo.export(outfile, level, namespace_, name_='processinfo', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='folder'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.mode is not None and 'mode' not in already_processed:
            already_processed.add('mode')
            showIndent(outfile, level)
            outfile.write('mode="%s",\n' % (self.mode,))
        if self.sequenceNumber is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            showIndent(outfile, level)
            outfile.write('sequenceNumber="%s",\n' % (self.sequenceNumber,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=%s,\n' % quote_python(self.value).encode(ExternalEncoding))
        if self.old_name is not None:
            showIndent(outfile, level)
            outfile.write('old_name=%s,\n' % quote_python(self.old_name).encode(ExternalEncoding))
        if self.new_name is not None:
            showIndent(outfile, level)
            outfile.write('new_name=%s,\n' % quote_python(self.new_name).encode(ExternalEncoding))
        if self.creationTime is not None:
            showIndent(outfile, level)
            outfile.write('creationTime=%s,\n' % quote_python(self.creationTime).encode(ExternalEncoding))
        if self.lastWriteTime is not None:
            showIndent(outfile, level)
            outfile.write('lastWriteTime=%s,\n' % quote_python(self.lastWriteTime).encode(ExternalEncoding))
        if self.changeTime is not None:
            showIndent(outfile, level)
            outfile.write('changeTime=%s,\n' % quote_python(self.changeTime).encode(ExternalEncoding))
        if self.newCreationTime is not None:
            showIndent(outfile, level)
            outfile.write('newCreationTime=%s,\n' % quote_python(self.newCreationTime).encode(ExternalEncoding))
        if self.newLastWriteTime is not None:
            showIndent(outfile, level)
            outfile.write('newLastWriteTime=%s,\n' % quote_python(self.newLastWriteTime).encode(ExternalEncoding))
        if self.newChangeTime is not None:
            showIndent(outfile, level)
            outfile.write('newChangeTime=%s,\n' % quote_python(self.newChangeTime).encode(ExternalEncoding))
        if self.processinfo is not None:
            showIndent(outfile, level)
            outfile.write('processinfo=model_.processinfo(\n')
            self.processinfo.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('mode', node)
        if value is not None and 'mode' not in already_processed:
            already_processed.add('mode')
            self.mode = value
        value = find_attr_value_('sequenceNumber', node)
        if value is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            self.sequenceNumber = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value = value_
        elif nodeName_ == 'old_name':
            old_name_ = child_.text
            old_name_ = self.gds_validate_string(old_name_, node, 'old_name')
            self.old_name = old_name_
        elif nodeName_ == 'new_name':
            new_name_ = child_.text
            new_name_ = self.gds_validate_string(new_name_, node, 'new_name')
            self.new_name = new_name_
        elif nodeName_ == 'creationTime':
            creationTime_ = child_.text
            creationTime_ = self.gds_validate_string(creationTime_, node, 'creationTime')
            self.creationTime = creationTime_
        elif nodeName_ == 'lastWriteTime':
            lastWriteTime_ = child_.text
            lastWriteTime_ = self.gds_validate_string(lastWriteTime_, node, 'lastWriteTime')
            self.lastWriteTime = lastWriteTime_
        elif nodeName_ == 'changeTime':
            changeTime_ = child_.text
            changeTime_ = self.gds_validate_string(changeTime_, node, 'changeTime')
            self.changeTime = changeTime_
        elif nodeName_ == 'newCreationTime':
            newCreationTime_ = child_.text
            newCreationTime_ = self.gds_validate_string(newCreationTime_, node, 'newCreationTime')
            self.newCreationTime = newCreationTime_
        elif nodeName_ == 'newLastWriteTime':
            newLastWriteTime_ = child_.text
            newLastWriteTime_ = self.gds_validate_string(newLastWriteTime_, node, 'newLastWriteTime')
            self.newLastWriteTime = newLastWriteTime_
        elif nodeName_ == 'newChangeTime':
            newChangeTime_ = child_.text
            newChangeTime_ = self.gds_validate_string(newChangeTime_, node, 'newChangeTime')
            self.newChangeTime = newChangeTime_
        elif nodeName_ == 'processinfo':
            obj_ = processinfo.factory()
            obj_.build(child_)
            self.processinfo = obj_
            obj_.original_tagname_ = 'processinfo'
# end class folder


class heapspraying(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, type_=None, name=None, sequenceNumber=None, processinfo=None, pattern=None, blocksize=None, address=None, bytesreceived=None, totalmemory=None, lastbytesreceived=None, lasttotalmemory=None, incrementCount=None):
        self.original_tagname_ = None
        self.type_ = _cast(None, type_)
        self.name = _cast(None, name)
        self.sequenceNumber = _cast(None, sequenceNumber)
        self.processinfo = processinfo
        self.pattern = pattern
        self.blocksize = blocksize
        self.address = address
        self.bytesreceived = bytesreceived
        self.totalmemory = totalmemory
        self.lastbytesreceived = lastbytesreceived
        self.lasttotalmemory = lasttotalmemory
        self.incrementCount = incrementCount
    def factory(*args_, **kwargs_):
        if heapspraying.subclass:
            return heapspraying.subclass(*args_, **kwargs_)
        else:
            return heapspraying(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_processinfo(self): return self.processinfo
    def set_processinfo(self, processinfo): self.processinfo = processinfo
    def get_pattern(self): return self.pattern
    def set_pattern(self, pattern): self.pattern = pattern
    def get_blocksize(self): return self.blocksize
    def set_blocksize(self, blocksize): self.blocksize = blocksize
    def get_address(self): return self.address
    def set_address(self, address): self.address = address
    def get_bytesreceived(self): return self.bytesreceived
    def set_bytesreceived(self, bytesreceived): self.bytesreceived = bytesreceived
    def get_totalmemory(self): return self.totalmemory
    def set_totalmemory(self, totalmemory): self.totalmemory = totalmemory
    def get_lastbytesreceived(self): return self.lastbytesreceived
    def set_lastbytesreceived(self, lastbytesreceived): self.lastbytesreceived = lastbytesreceived
    def get_lasttotalmemory(self): return self.lasttotalmemory
    def set_lasttotalmemory(self, lasttotalmemory): self.lasttotalmemory = lasttotalmemory
    def get_incrementCount(self): return self.incrementCount
    def set_incrementCount(self, incrementCount): self.incrementCount = incrementCount
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_sequenceNumber(self): return self.sequenceNumber
    def set_sequenceNumber(self, sequenceNumber): self.sequenceNumber = sequenceNumber
    def hasContent_(self):
        if (
            self.processinfo is not None or
            self.pattern is not None or
            self.blocksize is not None or
            self.address is not None or
            self.bytesreceived is not None or
            self.totalmemory is not None or
            self.lastbytesreceived is not None or
            self.lasttotalmemory is not None or
            self.incrementCount is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='heapspraying', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='heapspraying')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='heapspraying', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='heapspraying'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.sequenceNumber is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            outfile.write(' sequenceNumber=%s' % (self.gds_format_string(quote_attrib(self.sequenceNumber).encode(ExternalEncoding), input_name='sequenceNumber'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='heapspraying', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.processinfo is not None:
            self.processinfo.export(outfile, level, namespace_, name_='processinfo', pretty_print=pretty_print)
        if self.pattern is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spattern>%s</%spattern>%s' % (namespace_, self.gds_format_string(quote_xml(self.pattern).encode(ExternalEncoding), input_name='pattern'), namespace_, eol_))
        if self.blocksize is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sblocksize>%s</%sblocksize>%s' % (namespace_, self.gds_format_string(quote_xml(self.blocksize).encode(ExternalEncoding), input_name='blocksize'), namespace_, eol_))
        if self.address is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saddress>%s</%saddress>%s' % (namespace_, self.gds_format_string(quote_xml(self.address).encode(ExternalEncoding), input_name='address'), namespace_, eol_))
        if self.bytesreceived is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbytesreceived>%s</%sbytesreceived>%s' % (namespace_, self.gds_format_string(quote_xml(self.bytesreceived).encode(ExternalEncoding), input_name='bytesreceived'), namespace_, eol_))
        if self.totalmemory is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stotalmemory>%s</%stotalmemory>%s' % (namespace_, self.gds_format_string(quote_xml(self.totalmemory).encode(ExternalEncoding), input_name='totalmemory'), namespace_, eol_))
        if self.lastbytesreceived is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slastbytesreceived>%s</%slastbytesreceived>%s' % (namespace_, self.gds_format_string(quote_xml(self.lastbytesreceived).encode(ExternalEncoding), input_name='lastbytesreceived'), namespace_, eol_))
        if self.lasttotalmemory is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slasttotalmemory>%s</%slasttotalmemory>%s' % (namespace_, self.gds_format_string(quote_xml(self.lasttotalmemory).encode(ExternalEncoding), input_name='lasttotalmemory'), namespace_, eol_))
        if self.incrementCount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sincrementCount>%s</%sincrementCount>%s' % (namespace_, self.gds_format_string(quote_xml(self.incrementCount).encode(ExternalEncoding), input_name='incrementCount'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='heapspraying'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.sequenceNumber is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            showIndent(outfile, level)
            outfile.write('sequenceNumber="%s",\n' % (self.sequenceNumber,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.processinfo is not None:
            showIndent(outfile, level)
            outfile.write('processinfo=model_.processinfo(\n')
            self.processinfo.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.pattern is not None:
            showIndent(outfile, level)
            outfile.write('pattern=%s,\n' % quote_python(self.pattern).encode(ExternalEncoding))
        if self.blocksize is not None:
            showIndent(outfile, level)
            outfile.write('blocksize=%s,\n' % quote_python(self.blocksize).encode(ExternalEncoding))
        if self.address is not None:
            showIndent(outfile, level)
            outfile.write('address=%s,\n' % quote_python(self.address).encode(ExternalEncoding))
        if self.bytesreceived is not None:
            showIndent(outfile, level)
            outfile.write('bytesreceived=%s,\n' % quote_python(self.bytesreceived).encode(ExternalEncoding))
        if self.totalmemory is not None:
            showIndent(outfile, level)
            outfile.write('totalmemory=%s,\n' % quote_python(self.totalmemory).encode(ExternalEncoding))
        if self.lastbytesreceived is not None:
            showIndent(outfile, level)
            outfile.write('lastbytesreceived=%s,\n' % quote_python(self.lastbytesreceived).encode(ExternalEncoding))
        if self.lasttotalmemory is not None:
            showIndent(outfile, level)
            outfile.write('lasttotalmemory=%s,\n' % quote_python(self.lasttotalmemory).encode(ExternalEncoding))
        if self.incrementCount is not None:
            showIndent(outfile, level)
            outfile.write('incrementCount=%s,\n' % quote_python(self.incrementCount).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('sequenceNumber', node)
        if value is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            self.sequenceNumber = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'processinfo':
            obj_ = processinfo.factory()
            obj_.build(child_)
            self.processinfo = obj_
            obj_.original_tagname_ = 'processinfo'
        elif nodeName_ == 'pattern':
            pattern_ = child_.text
            pattern_ = self.gds_validate_string(pattern_, node, 'pattern')
            self.pattern = pattern_
        elif nodeName_ == 'blocksize':
            blocksize_ = child_.text
            blocksize_ = self.gds_validate_string(blocksize_, node, 'blocksize')
            self.blocksize = blocksize_
        elif nodeName_ == 'address':
            address_ = child_.text
            address_ = self.gds_validate_string(address_, node, 'address')
            self.address = address_
        elif nodeName_ == 'bytesreceived':
            bytesreceived_ = child_.text
            bytesreceived_ = self.gds_validate_string(bytesreceived_, node, 'bytesreceived')
            self.bytesreceived = bytesreceived_
        elif nodeName_ == 'totalmemory':
            totalmemory_ = child_.text
            totalmemory_ = self.gds_validate_string(totalmemory_, node, 'totalmemory')
            self.totalmemory = totalmemory_
        elif nodeName_ == 'lastbytesreceived':
            lastbytesreceived_ = child_.text
            lastbytesreceived_ = self.gds_validate_string(lastbytesreceived_, node, 'lastbytesreceived')
            self.lastbytesreceived = lastbytesreceived_
        elif nodeName_ == 'lasttotalmemory':
            lasttotalmemory_ = child_.text
            lasttotalmemory_ = self.gds_validate_string(lasttotalmemory_, node, 'lasttotalmemory')
            self.lasttotalmemory = lasttotalmemory_
        elif nodeName_ == 'incrementCount':
            incrementCount_ = child_.text
            incrementCount_ = self.gds_validate_string(incrementCount_, node, 'incrementCount')
            self.incrementCount = incrementCount_
# end class heapspraying


class malicious_alert(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, classtype=None, sequenceNumber=None, msg=None, display_msg=None):
        self.original_tagname_ = None
        self.classtype = _cast(None, classtype)
        self.sequenceNumber = _cast(None, sequenceNumber)
        self.msg = msg
        self.display_msg = display_msg
    def factory(*args_, **kwargs_):
        if malicious_alert.subclass:
            return malicious_alert.subclass(*args_, **kwargs_)
        else:
            return malicious_alert(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_msg(self): return self.msg
    def set_msg(self, msg): self.msg = msg
    def get_display_msg(self): return self.display_msg
    def set_display_msg(self, display_msg): self.display_msg = display_msg
    def get_classtype(self): return self.classtype
    def set_classtype(self, classtype): self.classtype = classtype
    def get_sequenceNumber(self): return self.sequenceNumber
    def set_sequenceNumber(self, sequenceNumber): self.sequenceNumber = sequenceNumber
    def hasContent_(self):
        if (
            self.msg is not None or
            self.display_msg is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='malicious-alert', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='malicious-alert')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='malicious-alert', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='malicious-alert'):
        if self.classtype is not None and 'classtype' not in already_processed:
            already_processed.add('classtype')
            outfile.write(' classtype=%s' % (self.gds_format_string(quote_attrib(self.classtype).encode(ExternalEncoding), input_name='classtype'), ))
        if self.sequenceNumber is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            outfile.write(' sequenceNumber=%s' % (self.gds_format_string(quote_attrib(self.sequenceNumber).encode(ExternalEncoding), input_name='sequenceNumber'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='malicious-alert', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.msg is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smsg>%s</%smsg>%s' % (namespace_, self.gds_format_string(quote_xml(self.msg).encode(ExternalEncoding), input_name='msg'), namespace_, eol_))
        if self.display_msg is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisplay-msg>%s</%sdisplay-msg>%s' % (namespace_, self.gds_format_string(quote_xml(self.display_msg).encode(ExternalEncoding), input_name='display-msg'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='malicious-alert'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.classtype is not None and 'classtype' not in already_processed:
            already_processed.add('classtype')
            showIndent(outfile, level)
            outfile.write('classtype="%s",\n' % (self.classtype,))
        if self.sequenceNumber is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            showIndent(outfile, level)
            outfile.write('sequenceNumber="%s",\n' % (self.sequenceNumber,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.msg is not None:
            showIndent(outfile, level)
            outfile.write('msg=%s,\n' % quote_python(self.msg).encode(ExternalEncoding))
        if self.display_msg is not None:
            showIndent(outfile, level)
            outfile.write('display_msg=%s,\n' % quote_python(self.display_msg).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('classtype', node)
        if value is not None and 'classtype' not in already_processed:
            already_processed.add('classtype')
            self.classtype = value
        value = find_attr_value_('sequenceNumber', node)
        if value is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            self.sequenceNumber = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'msg':
            msg_ = child_.text
            msg_ = self.gds_validate_string(msg_, node, 'msg')
            self.msg = msg_
        elif nodeName_ == 'display-msg':
            display_msg_ = child_.text
            display_msg_ = self.gds_validate_string(display_msg_, node, 'display_msg')
            self.display_msg = display_msg_
# end class malicious_alert


class mutex(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, sequenceNumber=None, value=None, processinfo=None):
        self.original_tagname_ = None
        self.sequenceNumber = _cast(None, sequenceNumber)
        self.value = value
        self.processinfo = processinfo
    def factory(*args_, **kwargs_):
        if mutex.subclass:
            return mutex.subclass(*args_, **kwargs_)
        else:
            return mutex(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_processinfo(self): return self.processinfo
    def set_processinfo(self, processinfo): self.processinfo = processinfo
    def get_sequenceNumber(self): return self.sequenceNumber
    def set_sequenceNumber(self, sequenceNumber): self.sequenceNumber = sequenceNumber
    def hasContent_(self):
        if (
            self.value is not None or
            self.processinfo is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='mutex', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='mutex')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='mutex', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='mutex'):
        if self.sequenceNumber is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            outfile.write(' sequenceNumber=%s' % (self.gds_format_string(quote_attrib(self.sequenceNumber).encode(ExternalEncoding), input_name='sequenceNumber'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='mutex', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_string(quote_xml(self.value).encode(ExternalEncoding), input_name='value'), namespace_, eol_))
        if self.processinfo is not None:
            self.processinfo.export(outfile, level, namespace_, name_='processinfo', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='mutex'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.sequenceNumber is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            showIndent(outfile, level)
            outfile.write('sequenceNumber="%s",\n' % (self.sequenceNumber,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=%s,\n' % quote_python(self.value).encode(ExternalEncoding))
        if self.processinfo is not None:
            showIndent(outfile, level)
            outfile.write('processinfo=model_.processinfo(\n')
            self.processinfo.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sequenceNumber', node)
        if value is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            self.sequenceNumber = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value = value_
        elif nodeName_ == 'processinfo':
            obj_ = processinfo.factory()
            obj_.build(child_)
            self.processinfo = obj_
            obj_.original_tagname_ = 'processinfo'
# end class mutex


class network(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, mode=None, sequenceNumber=None, processinfo=None, protocol_type=None, destination_port=None, listen_port=None, ipaddress=None, http_request=None, qtype=None, hostname=None, winsock_res=None, dns_response_code=None):
        self.original_tagname_ = None
        self.mode = _cast(None, mode)
        self.sequenceNumber = _cast(None, sequenceNumber)
        self.processinfo = processinfo
        self.protocol_type = protocol_type
        self.destination_port = destination_port
        self.listen_port = listen_port
        self.ipaddress = ipaddress
        self.http_request = http_request
        self.qtype = qtype
        self.hostname = hostname
        self.winsock_res = winsock_res
        self.dns_response_code = dns_response_code
    def factory(*args_, **kwargs_):
        if network.subclass:
            return network.subclass(*args_, **kwargs_)
        else:
            return network(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_processinfo(self): return self.processinfo
    def set_processinfo(self, processinfo): self.processinfo = processinfo
    def get_protocol_type(self): return self.protocol_type
    def set_protocol_type(self, protocol_type): self.protocol_type = protocol_type
    def get_destination_port(self): return self.destination_port
    def set_destination_port(self, destination_port): self.destination_port = destination_port
    def get_listen_port(self): return self.listen_port
    def set_listen_port(self, listen_port): self.listen_port = listen_port
    def get_ipaddress(self): return self.ipaddress
    def set_ipaddress(self, ipaddress): self.ipaddress = ipaddress
    def get_http_request(self): return self.http_request
    def set_http_request(self, http_request): self.http_request = http_request
    def get_qtype(self): return self.qtype
    def set_qtype(self, qtype): self.qtype = qtype
    def get_hostname(self): return self.hostname
    def set_hostname(self, hostname): self.hostname = hostname
    def get_winsock_res(self): return self.winsock_res
    def set_winsock_res(self, winsock_res): self.winsock_res = winsock_res
    def get_dns_response_code(self): return self.dns_response_code
    def set_dns_response_code(self, dns_response_code): self.dns_response_code = dns_response_code
    def get_mode(self): return self.mode
    def set_mode(self, mode): self.mode = mode
    def get_sequenceNumber(self): return self.sequenceNumber
    def set_sequenceNumber(self, sequenceNumber): self.sequenceNumber = sequenceNumber
    def hasContent_(self):
        if (
            self.processinfo is not None or
            self.protocol_type is not None or
            self.destination_port is not None or
            self.listen_port is not None or
            self.ipaddress is not None or
            self.http_request is not None or
            self.qtype is not None or
            self.hostname is not None or
            self.winsock_res is not None or
            self.dns_response_code is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='network', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='network')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='network', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='network'):
        if self.mode is not None and 'mode' not in already_processed:
            already_processed.add('mode')
            outfile.write(' mode=%s' % (self.gds_format_string(quote_attrib(self.mode).encode(ExternalEncoding), input_name='mode'), ))
        if self.sequenceNumber is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            outfile.write(' sequenceNumber=%s' % (self.gds_format_string(quote_attrib(self.sequenceNumber).encode(ExternalEncoding), input_name='sequenceNumber'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='network', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.processinfo is not None:
            self.processinfo.export(outfile, level, namespace_, name_='processinfo', pretty_print=pretty_print)
        if self.protocol_type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprotocol_type>%s</%sprotocol_type>%s' % (namespace_, self.gds_format_string(quote_xml(self.protocol_type).encode(ExternalEncoding), input_name='protocol_type'), namespace_, eol_))
        if self.destination_port is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdestination_port>%s</%sdestination_port>%s' % (namespace_, self.gds_format_string(quote_xml(self.destination_port).encode(ExternalEncoding), input_name='destination_port'), namespace_, eol_))
        if self.listen_port is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slisten_port>%s</%slisten_port>%s' % (namespace_, self.gds_format_string(quote_xml(self.listen_port).encode(ExternalEncoding), input_name='listen_port'), namespace_, eol_))
        if self.ipaddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sipaddress>%s</%sipaddress>%s' % (namespace_, self.gds_format_string(quote_xml(self.ipaddress).encode(ExternalEncoding), input_name='ipaddress'), namespace_, eol_))
        if self.http_request is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%shttp_request>%s</%shttp_request>%s' % (namespace_, self.gds_format_string(quote_xml(self.http_request).encode(ExternalEncoding), input_name='http_request'), namespace_, eol_))
        if self.qtype is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sqtype>%s</%sqtype>%s' % (namespace_, self.gds_format_string(quote_xml(self.qtype).encode(ExternalEncoding), input_name='qtype'), namespace_, eol_))
        if self.hostname is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%shostname>%s</%shostname>%s' % (namespace_, self.gds_format_string(quote_xml(self.hostname).encode(ExternalEncoding), input_name='hostname'), namespace_, eol_))
        if self.winsock_res is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%swinsock_res>%s</%swinsock_res>%s' % (namespace_, self.gds_format_string(quote_xml(self.winsock_res).encode(ExternalEncoding), input_name='winsock_res'), namespace_, eol_))
        if self.dns_response_code is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdns_response_code>%s</%sdns_response_code>%s' % (namespace_, self.gds_format_string(quote_xml(self.dns_response_code).encode(ExternalEncoding), input_name='dns_response_code'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='network'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.mode is not None and 'mode' not in already_processed:
            already_processed.add('mode')
            showIndent(outfile, level)
            outfile.write('mode="%s",\n' % (self.mode,))
        if self.sequenceNumber is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            showIndent(outfile, level)
            outfile.write('sequenceNumber="%s",\n' % (self.sequenceNumber,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.processinfo is not None:
            showIndent(outfile, level)
            outfile.write('processinfo=model_.processinfo(\n')
            self.processinfo.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.protocol_type is not None:
            showIndent(outfile, level)
            outfile.write('protocol_type=%s,\n' % quote_python(self.protocol_type).encode(ExternalEncoding))
        if self.destination_port is not None:
            showIndent(outfile, level)
            outfile.write('destination_port=%s,\n' % quote_python(self.destination_port).encode(ExternalEncoding))
        if self.listen_port is not None:
            showIndent(outfile, level)
            outfile.write('listen_port=%s,\n' % quote_python(self.listen_port).encode(ExternalEncoding))
        if self.ipaddress is not None:
            showIndent(outfile, level)
            outfile.write('ipaddress=%s,\n' % quote_python(self.ipaddress).encode(ExternalEncoding))
        if self.http_request is not None:
            showIndent(outfile, level)
            outfile.write('http_request=%s,\n' % quote_python(self.http_request).encode(ExternalEncoding))
        if self.qtype is not None:
            showIndent(outfile, level)
            outfile.write('qtype=%s,\n' % quote_python(self.qtype).encode(ExternalEncoding))
        if self.hostname is not None:
            showIndent(outfile, level)
            outfile.write('hostname=%s,\n' % quote_python(self.hostname).encode(ExternalEncoding))
        if self.winsock_res is not None:
            showIndent(outfile, level)
            outfile.write('winsock_res=%s,\n' % quote_python(self.winsock_res).encode(ExternalEncoding))
        if self.dns_response_code is not None:
            showIndent(outfile, level)
            outfile.write('dns_response_code=%s,\n' % quote_python(self.dns_response_code).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('mode', node)
        if value is not None and 'mode' not in already_processed:
            already_processed.add('mode')
            self.mode = value
        value = find_attr_value_('sequenceNumber', node)
        if value is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            self.sequenceNumber = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'processinfo':
            obj_ = processinfo.factory()
            obj_.build(child_)
            self.processinfo = obj_
            obj_.original_tagname_ = 'processinfo'
        elif nodeName_ == 'protocol_type':
            protocol_type_ = child_.text
            protocol_type_ = self.gds_validate_string(protocol_type_, node, 'protocol_type')
            self.protocol_type = protocol_type_
        elif nodeName_ == 'destination_port':
            destination_port_ = child_.text
            destination_port_ = self.gds_validate_string(destination_port_, node, 'destination_port')
            self.destination_port = destination_port_
        elif nodeName_ == 'listen_port':
            listen_port_ = child_.text
            listen_port_ = self.gds_validate_string(listen_port_, node, 'listen_port')
            self.listen_port = listen_port_
        elif nodeName_ == 'ipaddress':
            ipaddress_ = child_.text
            ipaddress_ = self.gds_validate_string(ipaddress_, node, 'ipaddress')
            self.ipaddress = ipaddress_
        elif nodeName_ == 'http_request':
            http_request_ = child_.text
            http_request_ = self.gds_validate_string(http_request_, node, 'http_request')
            self.http_request = http_request_
        elif nodeName_ == 'qtype':
            qtype_ = child_.text
            qtype_ = self.gds_validate_string(qtype_, node, 'qtype')
            self.qtype = qtype_
        elif nodeName_ == 'hostname':
            hostname_ = child_.text
            hostname_ = self.gds_validate_string(hostname_, node, 'hostname')
            self.hostname = hostname_
        elif nodeName_ == 'winsock_res':
            winsock_res_ = child_.text
            winsock_res_ = self.gds_validate_string(winsock_res_, node, 'winsock_res')
            self.winsock_res = winsock_res_
        elif nodeName_ == 'dns_response_code':
            dns_response_code_ = child_.text
            dns_response_code_ = self.gds_validate_string(dns_response_code_, node, 'dns_response_code')
            self.dns_response_code = dns_response_code_
# end class network


class process(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, mode=None, sequenceNumber=None, value=None, pid=None, ppid=None, parentname=None, cmdline=None, filesize=None, md5sum=None, sha1sum=None, packed=None, gui=None, fid=None):
        self.original_tagname_ = None
        self.mode = _cast(None, mode)
        self.sequenceNumber = _cast(None, sequenceNumber)
        self.value = value
        self.pid = pid
        self.ppid = ppid
        self.parentname = parentname
        self.cmdline = cmdline
        self.filesize = filesize
        self.md5sum = md5sum
        self.sha1sum = sha1sum
        self.packed = packed
        self.gui = gui
        self.fid = fid
    def factory(*args_, **kwargs_):
        if process.subclass:
            return process.subclass(*args_, **kwargs_)
        else:
            return process(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_pid(self): return self.pid
    def set_pid(self, pid): self.pid = pid
    def get_ppid(self): return self.ppid
    def set_ppid(self, ppid): self.ppid = ppid
    def get_parentname(self): return self.parentname
    def set_parentname(self, parentname): self.parentname = parentname
    def get_cmdline(self): return self.cmdline
    def set_cmdline(self, cmdline): self.cmdline = cmdline
    def get_filesize(self): return self.filesize
    def set_filesize(self, filesize): self.filesize = filesize
    def get_md5sum(self): return self.md5sum
    def set_md5sum(self, md5sum): self.md5sum = md5sum
    def get_sha1sum(self): return self.sha1sum
    def set_sha1sum(self, sha1sum): self.sha1sum = sha1sum
    def get_packed(self): return self.packed
    def set_packed(self, packed): self.packed = packed
    def get_gui(self): return self.gui
    def set_gui(self, gui): self.gui = gui
    def get_fid(self): return self.fid
    def set_fid(self, fid): self.fid = fid
    def get_mode(self): return self.mode
    def set_mode(self, mode): self.mode = mode
    def get_sequenceNumber(self): return self.sequenceNumber
    def set_sequenceNumber(self, sequenceNumber): self.sequenceNumber = sequenceNumber
    def hasContent_(self):
        if (
            self.value is not None or
            self.pid is not None or
            self.ppid is not None or
            self.parentname is not None or
            self.cmdline is not None or
            self.filesize is not None or
            self.md5sum is not None or
            self.sha1sum is not None or
            self.packed is not None or
            self.gui is not None or
            self.fid is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='process', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='process')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='process', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='process'):
        if self.mode is not None and 'mode' not in already_processed:
            already_processed.add('mode')
            outfile.write(' mode=%s' % (self.gds_format_string(quote_attrib(self.mode).encode(ExternalEncoding), input_name='mode'), ))
        if self.sequenceNumber is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            outfile.write(' sequenceNumber=%s' % (self.gds_format_string(quote_attrib(self.sequenceNumber).encode(ExternalEncoding), input_name='sequenceNumber'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='process', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_string(quote_xml(self.value).encode(ExternalEncoding), input_name='value'), namespace_, eol_))
        if self.pid is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spid>%s</%spid>%s' % (namespace_, self.gds_format_string(quote_xml(self.pid).encode(ExternalEncoding), input_name='pid'), namespace_, eol_))
        if self.ppid is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sppid>%s</%sppid>%s' % (namespace_, self.gds_format_string(quote_xml(self.ppid).encode(ExternalEncoding), input_name='ppid'), namespace_, eol_))
        if self.parentname is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sparentname>%s</%sparentname>%s' % (namespace_, self.gds_format_string(quote_xml(self.parentname).encode(ExternalEncoding), input_name='parentname'), namespace_, eol_))
        if self.cmdline is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scmdline>%s</%scmdline>%s' % (namespace_, self.gds_format_string(quote_xml(self.cmdline).encode(ExternalEncoding), input_name='cmdline'), namespace_, eol_))
        if self.filesize is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfilesize>%s</%sfilesize>%s' % (namespace_, self.gds_format_string(quote_xml(self.filesize).encode(ExternalEncoding), input_name='filesize'), namespace_, eol_))
        if self.md5sum is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smd5sum>%s</%smd5sum>%s' % (namespace_, self.gds_format_string(quote_xml(self.md5sum).encode(ExternalEncoding), input_name='md5sum'), namespace_, eol_))
        if self.sha1sum is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssha1sum>%s</%ssha1sum>%s' % (namespace_, self.gds_format_string(quote_xml(self.sha1sum).encode(ExternalEncoding), input_name='sha1sum'), namespace_, eol_))
        if self.packed is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spacked>%s</%spacked>%s' % (namespace_, self.gds_format_string(quote_xml(self.packed).encode(ExternalEncoding), input_name='packed'), namespace_, eol_))
        if self.gui is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sgui>%s</%sgui>%s' % (namespace_, self.gds_format_string(quote_xml(self.gui).encode(ExternalEncoding), input_name='gui'), namespace_, eol_))
        if self.fid is not None:
            self.fid.export(outfile, level, namespace_, name_='fid', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='process'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.mode is not None and 'mode' not in already_processed:
            already_processed.add('mode')
            showIndent(outfile, level)
            outfile.write('mode="%s",\n' % (self.mode,))
        if self.sequenceNumber is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            showIndent(outfile, level)
            outfile.write('sequenceNumber="%s",\n' % (self.sequenceNumber,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=%s,\n' % quote_python(self.value).encode(ExternalEncoding))
        if self.pid is not None:
            showIndent(outfile, level)
            outfile.write('pid=%s,\n' % quote_python(self.pid).encode(ExternalEncoding))
        if self.ppid is not None:
            showIndent(outfile, level)
            outfile.write('ppid=%s,\n' % quote_python(self.ppid).encode(ExternalEncoding))
        if self.parentname is not None:
            showIndent(outfile, level)
            outfile.write('parentname=%s,\n' % quote_python(self.parentname).encode(ExternalEncoding))
        if self.cmdline is not None:
            showIndent(outfile, level)
            outfile.write('cmdline=%s,\n' % quote_python(self.cmdline).encode(ExternalEncoding))
        if self.filesize is not None:
            showIndent(outfile, level)
            outfile.write('filesize=%s,\n' % quote_python(self.filesize).encode(ExternalEncoding))
        if self.md5sum is not None:
            showIndent(outfile, level)
            outfile.write('md5sum=%s,\n' % quote_python(self.md5sum).encode(ExternalEncoding))
        if self.sha1sum is not None:
            showIndent(outfile, level)
            outfile.write('sha1sum=%s,\n' % quote_python(self.sha1sum).encode(ExternalEncoding))
        if self.packed is not None:
            showIndent(outfile, level)
            outfile.write('packed=%s,\n' % quote_python(self.packed).encode(ExternalEncoding))
        if self.gui is not None:
            showIndent(outfile, level)
            outfile.write('gui=%s,\n' % quote_python(self.gui).encode(ExternalEncoding))
        if self.fid is not None:
            showIndent(outfile, level)
            outfile.write('fid=model_.fid(\n')
            self.fid.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('mode', node)
        if value is not None and 'mode' not in already_processed:
            already_processed.add('mode')
            self.mode = value
        value = find_attr_value_('sequenceNumber', node)
        if value is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            self.sequenceNumber = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value = value_
        elif nodeName_ == 'pid':
            pid_ = child_.text
            pid_ = self.gds_validate_string(pid_, node, 'pid')
            self.pid = pid_
        elif nodeName_ == 'ppid':
            ppid_ = child_.text
            ppid_ = self.gds_validate_string(ppid_, node, 'ppid')
            self.ppid = ppid_
        elif nodeName_ == 'parentname':
            parentname_ = child_.text
            parentname_ = self.gds_validate_string(parentname_, node, 'parentname')
            self.parentname = parentname_
        elif nodeName_ == 'cmdline':
            cmdline_ = child_.text
            cmdline_ = self.gds_validate_string(cmdline_, node, 'cmdline')
            self.cmdline = cmdline_
        elif nodeName_ == 'filesize':
            filesize_ = child_.text
            filesize_ = self.gds_validate_string(filesize_, node, 'filesize')
            self.filesize = filesize_
        elif nodeName_ == 'md5sum':
            md5sum_ = child_.text
            md5sum_ = self.gds_validate_string(md5sum_, node, 'md5sum')
            self.md5sum = md5sum_
        elif nodeName_ == 'sha1sum':
            sha1sum_ = child_.text
            sha1sum_ = self.gds_validate_string(sha1sum_, node, 'sha1sum')
            self.sha1sum = sha1sum_
        elif nodeName_ == 'packed':
            packed_ = child_.text
            packed_ = self.gds_validate_string(packed_, node, 'packed')
            self.packed = packed_
        elif nodeName_ == 'gui':
            gui_ = child_.text
            gui_ = self.gds_validate_string(gui_, node, 'gui')
            self.gui = gui_
        elif nodeName_ == 'fid':
            obj_ = fid.factory()
            obj_.build(child_)
            self.fid = obj_
            obj_.original_tagname_ = 'fid'
# end class process


class process_packed(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, sequenceNumber=None, processinfo=None):
        self.original_tagname_ = None
        self.sequenceNumber = _cast(None, sequenceNumber)
        self.processinfo = processinfo
    def factory(*args_, **kwargs_):
        if process_packed.subclass:
            return process_packed.subclass(*args_, **kwargs_)
        else:
            return process_packed(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_processinfo(self): return self.processinfo
    def set_processinfo(self, processinfo): self.processinfo = processinfo
    def get_sequenceNumber(self): return self.sequenceNumber
    def set_sequenceNumber(self, sequenceNumber): self.sequenceNumber = sequenceNumber
    def hasContent_(self):
        if (
            self.processinfo is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='process-packed', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='process-packed')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='process-packed', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='process-packed'):
        if self.sequenceNumber is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            outfile.write(' sequenceNumber=%s' % (self.gds_format_string(quote_attrib(self.sequenceNumber).encode(ExternalEncoding), input_name='sequenceNumber'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='process-packed', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.processinfo is not None:
            self.processinfo.export(outfile, level, namespace_, name_='processinfo', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='process-packed'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.sequenceNumber is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            showIndent(outfile, level)
            outfile.write('sequenceNumber="%s",\n' % (self.sequenceNumber,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.processinfo is not None:
            showIndent(outfile, level)
            outfile.write('processinfo=model_.processinfo(\n')
            self.processinfo.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sequenceNumber', node)
        if value is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            self.sequenceNumber = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'processinfo':
            obj_ = processinfo.factory()
            obj_.build(child_)
            self.processinfo = obj_
            obj_.original_tagname_ = 'processinfo'
# end class process_packed


class processstats(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, sequenceNumber=None, processinfo=None, bytesreceived=None, totalmemory=None, id=None, deltatime=None):
        self.original_tagname_ = None
        self.sequenceNumber = _cast(None, sequenceNumber)
        self.processinfo = processinfo
        self.bytesreceived = bytesreceived
        self.totalmemory = totalmemory
        self.id = id
        self.deltatime = deltatime
    def factory(*args_, **kwargs_):
        if processstats.subclass:
            return processstats.subclass(*args_, **kwargs_)
        else:
            return processstats(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_processinfo(self): return self.processinfo
    def set_processinfo(self, processinfo): self.processinfo = processinfo
    def get_bytesreceived(self): return self.bytesreceived
    def set_bytesreceived(self, bytesreceived): self.bytesreceived = bytesreceived
    def get_totalmemory(self): return self.totalmemory
    def set_totalmemory(self, totalmemory): self.totalmemory = totalmemory
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_deltatime(self): return self.deltatime
    def set_deltatime(self, deltatime): self.deltatime = deltatime
    def get_sequenceNumber(self): return self.sequenceNumber
    def set_sequenceNumber(self, sequenceNumber): self.sequenceNumber = sequenceNumber
    def hasContent_(self):
        if (
            self.processinfo is not None or
            self.bytesreceived is not None or
            self.totalmemory is not None or
            self.id is not None or
            self.deltatime is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='processstats', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='processstats')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='processstats', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='processstats'):
        if self.sequenceNumber is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            outfile.write(' sequenceNumber=%s' % (self.gds_format_string(quote_attrib(self.sequenceNumber).encode(ExternalEncoding), input_name='sequenceNumber'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='processstats', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.processinfo is not None:
            self.processinfo.export(outfile, level, namespace_, name_='processinfo', pretty_print=pretty_print)
        if self.bytesreceived is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbytesreceived>%s</%sbytesreceived>%s' % (namespace_, self.gds_format_string(quote_xml(self.bytesreceived).encode(ExternalEncoding), input_name='bytesreceived'), namespace_, eol_))
        if self.totalmemory is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stotalmemory>%s</%stotalmemory>%s' % (namespace_, self.gds_format_string(quote_xml(self.totalmemory).encode(ExternalEncoding), input_name='totalmemory'), namespace_, eol_))
        if self.id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sid>%s</%sid>%s' % (namespace_, self.gds_format_string(quote_xml(self.id).encode(ExternalEncoding), input_name='id'), namespace_, eol_))
        if self.deltatime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdeltatime>%s</%sdeltatime>%s' % (namespace_, self.gds_format_string(quote_xml(self.deltatime).encode(ExternalEncoding), input_name='deltatime'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='processstats'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.sequenceNumber is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            showIndent(outfile, level)
            outfile.write('sequenceNumber="%s",\n' % (self.sequenceNumber,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.processinfo is not None:
            showIndent(outfile, level)
            outfile.write('processinfo=model_.processinfo(\n')
            self.processinfo.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.bytesreceived is not None:
            showIndent(outfile, level)
            outfile.write('bytesreceived=%s,\n' % quote_python(self.bytesreceived).encode(ExternalEncoding))
        if self.totalmemory is not None:
            showIndent(outfile, level)
            outfile.write('totalmemory=%s,\n' % quote_python(self.totalmemory).encode(ExternalEncoding))
        if self.id is not None:
            showIndent(outfile, level)
            outfile.write('id=%s,\n' % quote_python(self.id).encode(ExternalEncoding))
        if self.deltatime is not None:
            showIndent(outfile, level)
            outfile.write('deltatime=%s,\n' % quote_python(self.deltatime).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sequenceNumber', node)
        if value is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            self.sequenceNumber = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'processinfo':
            obj_ = processinfo.factory()
            obj_.build(child_)
            self.processinfo = obj_
            obj_.original_tagname_ = 'processinfo'
        elif nodeName_ == 'bytesreceived':
            bytesreceived_ = child_.text
            bytesreceived_ = self.gds_validate_string(bytesreceived_, node, 'bytesreceived')
            self.bytesreceived = bytesreceived_
        elif nodeName_ == 'totalmemory':
            totalmemory_ = child_.text
            totalmemory_ = self.gds_validate_string(totalmemory_, node, 'totalmemory')
            self.totalmemory = totalmemory_
        elif nodeName_ == 'id':
            id_ = child_.text
            id_ = self.gds_validate_string(id_, node, 'id')
            self.id = id_
        elif nodeName_ == 'deltatime':
            deltatime_ = child_.text
            deltatime_ = self.gds_validate_string(deltatime_, node, 'deltatime')
            self.deltatime = deltatime_
# end class processstats


class regkey(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, mode=None, sequenceNumber=None, value=None, processinfo=None):
        self.original_tagname_ = None
        self.mode = _cast(None, mode)
        self.sequenceNumber = _cast(None, sequenceNumber)
        self.value = value
        self.processinfo = processinfo
    def factory(*args_, **kwargs_):
        if regkey.subclass:
            return regkey.subclass(*args_, **kwargs_)
        else:
            return regkey(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_processinfo(self): return self.processinfo
    def set_processinfo(self, processinfo): self.processinfo = processinfo
    def get_mode(self): return self.mode
    def set_mode(self, mode): self.mode = mode
    def get_sequenceNumber(self): return self.sequenceNumber
    def set_sequenceNumber(self, sequenceNumber): self.sequenceNumber = sequenceNumber
    def hasContent_(self):
        if (
            self.value is not None or
            self.processinfo is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='regkey', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='regkey')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='regkey', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='regkey'):
        if self.mode is not None and 'mode' not in already_processed:
            already_processed.add('mode')
            outfile.write(' mode=%s' % (self.gds_format_string(quote_attrib(self.mode).encode(ExternalEncoding), input_name='mode'), ))
        if self.sequenceNumber is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            outfile.write(' sequenceNumber=%s' % (self.gds_format_string(quote_attrib(self.sequenceNumber).encode(ExternalEncoding), input_name='sequenceNumber'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='regkey', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_string(quote_xml(self.value).encode(ExternalEncoding), input_name='value'), namespace_, eol_))
        if self.processinfo is not None:
            self.processinfo.export(outfile, level, namespace_, name_='processinfo', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='regkey'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.mode is not None and 'mode' not in already_processed:
            already_processed.add('mode')
            showIndent(outfile, level)
            outfile.write('mode="%s",\n' % (self.mode,))
        if self.sequenceNumber is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            showIndent(outfile, level)
            outfile.write('sequenceNumber="%s",\n' % (self.sequenceNumber,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=%s,\n' % quote_python(self.value).encode(ExternalEncoding))
        if self.processinfo is not None:
            showIndent(outfile, level)
            outfile.write('processinfo=model_.processinfo(\n')
            self.processinfo.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('mode', node)
        if value is not None and 'mode' not in already_processed:
            already_processed.add('mode')
            self.mode = value
        value = find_attr_value_('sequenceNumber', node)
        if value is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            self.sequenceNumber = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value = value_
        elif nodeName_ == 'processinfo':
            obj_ = processinfo.factory()
            obj_.build(child_)
            self.processinfo = obj_
            obj_.original_tagname_ = 'processinfo'
# end class regkey


class os_inactivity_send_keys(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, sequenceNumber=None):
        self.original_tagname_ = None
        self.sequenceNumber = _cast(None, sequenceNumber)
    def factory(*args_, **kwargs_):
        if os_inactivity_send_keys.subclass:
            return os_inactivity_send_keys.subclass(*args_, **kwargs_)
        else:
            return os_inactivity_send_keys(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_sequenceNumber(self): return self.sequenceNumber
    def set_sequenceNumber(self, sequenceNumber): self.sequenceNumber = sequenceNumber
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='os-inactivity-send-keys', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='os-inactivity-send-keys')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='os-inactivity-send-keys', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='os-inactivity-send-keys'):
        if self.sequenceNumber is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            outfile.write(' sequenceNumber=%s' % (self.gds_format_string(quote_attrib(self.sequenceNumber).encode(ExternalEncoding), input_name='sequenceNumber'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='os-inactivity-send-keys', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='os-inactivity-send-keys'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.sequenceNumber is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            showIndent(outfile, level)
            outfile.write('sequenceNumber="%s",\n' % (self.sequenceNumber,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sequenceNumber', node)
        if value is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            self.sequenceNumber = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class os_inactivity_send_keys


class end_of_report(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, sequenceNumber=None):
        self.original_tagname_ = None
        self.sequenceNumber = _cast(None, sequenceNumber)
    def factory(*args_, **kwargs_):
        if end_of_report.subclass:
            return end_of_report.subclass(*args_, **kwargs_)
        else:
            return end_of_report(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_sequenceNumber(self): return self.sequenceNumber
    def set_sequenceNumber(self, sequenceNumber): self.sequenceNumber = sequenceNumber
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='end-of-report', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='end-of-report')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='end-of-report', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='end-of-report'):
        if self.sequenceNumber is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            outfile.write(' sequenceNumber=%s' % (self.gds_format_string(quote_attrib(self.sequenceNumber).encode(ExternalEncoding), input_name='sequenceNumber'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='end-of-report', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='end-of-report'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.sequenceNumber is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            showIndent(outfile, level)
            outfile.write('sequenceNumber="%s",\n' % (self.sequenceNumber,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sequenceNumber', node)
        if value is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            self.sequenceNumber = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class end_of_report


class processinfo(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, sequenceNumber=None, pid=None, imagepath=None, md5sum=None):
        self.original_tagname_ = None
        self.sequenceNumber = _cast(None, sequenceNumber)
        self.pid = pid
        self.imagepath = imagepath
        self.md5sum = md5sum
    def factory(*args_, **kwargs_):
        if processinfo.subclass:
            return processinfo.subclass(*args_, **kwargs_)
        else:
            return processinfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_pid(self): return self.pid
    def set_pid(self, pid): self.pid = pid
    def get_imagepath(self): return self.imagepath
    def set_imagepath(self, imagepath): self.imagepath = imagepath
    def get_md5sum(self): return self.md5sum
    def set_md5sum(self, md5sum): self.md5sum = md5sum
    def get_sequenceNumber(self): return self.sequenceNumber
    def set_sequenceNumber(self, sequenceNumber): self.sequenceNumber = sequenceNumber
    def hasContent_(self):
        if (
            self.pid is not None or
            self.imagepath is not None or
            self.md5sum is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='processinfo', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='processinfo')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='processinfo', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='processinfo'):
        if self.sequenceNumber is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            outfile.write(' sequenceNumber=%s' % (self.gds_format_string(quote_attrib(self.sequenceNumber).encode(ExternalEncoding), input_name='sequenceNumber'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='processinfo', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.pid is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spid>%s</%spid>%s' % (namespace_, self.gds_format_string(quote_xml(self.pid).encode(ExternalEncoding), input_name='pid'), namespace_, eol_))
        if self.imagepath is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%simagepath>%s</%simagepath>%s' % (namespace_, self.gds_format_string(quote_xml(self.imagepath).encode(ExternalEncoding), input_name='imagepath'), namespace_, eol_))
        if self.md5sum is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smd5sum>%s</%smd5sum>%s' % (namespace_, self.gds_format_string(quote_xml(self.md5sum).encode(ExternalEncoding), input_name='md5sum'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='processinfo'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.sequenceNumber is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            showIndent(outfile, level)
            outfile.write('sequenceNumber="%s",\n' % (self.sequenceNumber,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.pid is not None:
            showIndent(outfile, level)
            outfile.write('pid=%s,\n' % quote_python(self.pid).encode(ExternalEncoding))
        if self.imagepath is not None:
            showIndent(outfile, level)
            outfile.write('imagepath=%s,\n' % quote_python(self.imagepath).encode(ExternalEncoding))
        if self.md5sum is not None:
            showIndent(outfile, level)
            outfile.write('md5sum=%s,\n' % quote_python(self.md5sum).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sequenceNumber', node)
        if value is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            self.sequenceNumber = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'pid':
            pid_ = child_.text
            pid_ = self.gds_validate_string(pid_, node, 'pid')
            self.pid = pid_
        elif nodeName_ == 'imagepath':
            imagepath_ = child_.text
            imagepath_ = self.gds_validate_string(imagepath_, node, 'imagepath')
            self.imagepath = imagepath_
        elif nodeName_ == 'md5sum':
            md5sum_ = child_.text
            md5sum_ = self.gds_validate_string(md5sum_, node, 'md5sum')
            self.md5sum = md5sum_
# end class processinfo


class params(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, sequenceNumber=None, param=None):
        self.original_tagname_ = None
        self.sequenceNumber = _cast(None, sequenceNumber)
        if param is None:
            self.param = []
        else:
            self.param = param
    def factory(*args_, **kwargs_):
        if params.subclass:
            return params.subclass(*args_, **kwargs_)
        else:
            return params(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_param(self): return self.param
    def set_param(self, param): self.param = param
    def add_param(self, value): self.param.append(value)
    def insert_param_at(self, index, value): self.param.insert(index, value)
    def replace_param_at(self, index, value): self.param[index] = value
    def get_sequenceNumber(self): return self.sequenceNumber
    def set_sequenceNumber(self, sequenceNumber): self.sequenceNumber = sequenceNumber
    def hasContent_(self):
        if (
            self.param
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='params', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='params')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='params', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='params'):
        if self.sequenceNumber is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            outfile.write(' sequenceNumber=%s' % (self.gds_format_string(quote_attrib(self.sequenceNumber).encode(ExternalEncoding), input_name='sequenceNumber'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='params', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for param_ in self.param:
            param_.export(outfile, level, namespace_, name_='param', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='params'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.sequenceNumber is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            showIndent(outfile, level)
            outfile.write('sequenceNumber="%s",\n' % (self.sequenceNumber,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('param=[\n')
        level += 1
        for param_ in self.param:
            showIndent(outfile, level)
            outfile.write('model_.param(\n')
            param_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sequenceNumber', node)
        if value is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            self.sequenceNumber = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'param':
            obj_ = param.factory()
            obj_.build(child_)
            self.param.append(obj_)
            obj_.original_tagname_ = 'param'
# end class params


class param(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, sequenceNumber=None, valueOf_=None):
        self.original_tagname_ = None
        self.id = _cast(int, id)
        self.sequenceNumber = _cast(None, sequenceNumber)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if param.subclass:
            return param.subclass(*args_, **kwargs_)
        else:
            return param(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_sequenceNumber(self): return self.sequenceNumber
    def set_sequenceNumber(self, sequenceNumber): self.sequenceNumber = sequenceNumber
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='param', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='param')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='param', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='param'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id="%s"' % self.gds_format_integer(self.id, input_name='id'))
        if self.sequenceNumber is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            outfile.write(' sequenceNumber=%s' % (self.gds_format_string(quote_attrib(self.sequenceNumber).encode(ExternalEncoding), input_name='sequenceNumber'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='param', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='param'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id=%d,\n' % (self.id,))
        if self.sequenceNumber is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            showIndent(outfile, level)
            outfile.write('sequenceNumber="%s",\n' % (self.sequenceNumber,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            try:
                self.id = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('sequenceNumber', node)
        if value is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            self.sequenceNumber = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class param


class callstack(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, sequenceNumber=None, callstack_entry=None):
        self.original_tagname_ = None
        self.sequenceNumber = _cast(None, sequenceNumber)
        if callstack_entry is None:
            self.callstack_entry = []
        else:
            self.callstack_entry = callstack_entry
    def factory(*args_, **kwargs_):
        if callstack.subclass:
            return callstack.subclass(*args_, **kwargs_)
        else:
            return callstack(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_callstack_entry(self): return self.callstack_entry
    def set_callstack_entry(self, callstack_entry): self.callstack_entry = callstack_entry
    def add_callstack_entry(self, value): self.callstack_entry.append(value)
    def insert_callstack_entry_at(self, index, value): self.callstack_entry.insert(index, value)
    def replace_callstack_entry_at(self, index, value): self.callstack_entry[index] = value
    def get_sequenceNumber(self): return self.sequenceNumber
    def set_sequenceNumber(self, sequenceNumber): self.sequenceNumber = sequenceNumber
    def hasContent_(self):
        if (
            self.callstack_entry
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='callstack', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='callstack')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='callstack', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='callstack'):
        if self.sequenceNumber is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            outfile.write(' sequenceNumber=%s' % (self.gds_format_string(quote_attrib(self.sequenceNumber).encode(ExternalEncoding), input_name='sequenceNumber'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='callstack', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for callstack_entry_ in self.callstack_entry:
            callstack_entry_.export(outfile, level, namespace_, name_='callstack-entry', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='callstack'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.sequenceNumber is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            showIndent(outfile, level)
            outfile.write('sequenceNumber="%s",\n' % (self.sequenceNumber,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('callstack_entry=[\n')
        level += 1
        for callstack_entry_ in self.callstack_entry:
            showIndent(outfile, level)
            outfile.write('model_.callstack_entry(\n')
            callstack_entry_.exportLiteral(outfile, level, name_='callstack-entry')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sequenceNumber', node)
        if value is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            self.sequenceNumber = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'callstack-entry':
            obj_ = callstack_entry.factory()
            obj_.build(child_)
            self.callstack_entry.append(obj_)
            obj_.original_tagname_ = 'callstack-entry'
# end class callstack


class callstack_entry(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, sequenceNumber=None, frame_number=None, instruction_address=None, module_name=None, symbol_name=None, symbol_displacement=None):
        self.original_tagname_ = None
        self.sequenceNumber = _cast(None, sequenceNumber)
        if frame_number is None:
            self.frame_number = []
        else:
            self.frame_number = frame_number
        if instruction_address is None:
            self.instruction_address = []
        else:
            self.instruction_address = instruction_address
        if module_name is None:
            self.module_name = []
        else:
            self.module_name = module_name
        if symbol_name is None:
            self.symbol_name = []
        else:
            self.symbol_name = symbol_name
        if symbol_displacement is None:
            self.symbol_displacement = []
        else:
            self.symbol_displacement = symbol_displacement
    def factory(*args_, **kwargs_):
        if callstack_entry.subclass:
            return callstack_entry.subclass(*args_, **kwargs_)
        else:
            return callstack_entry(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_frame_number(self): return self.frame_number
    def set_frame_number(self, frame_number): self.frame_number = frame_number
    def add_frame_number(self, value): self.frame_number.append(value)
    def insert_frame_number_at(self, index, value): self.frame_number.insert(index, value)
    def replace_frame_number_at(self, index, value): self.frame_number[index] = value
    def get_instruction_address(self): return self.instruction_address
    def set_instruction_address(self, instruction_address): self.instruction_address = instruction_address
    def add_instruction_address(self, value): self.instruction_address.append(value)
    def insert_instruction_address_at(self, index, value): self.instruction_address.insert(index, value)
    def replace_instruction_address_at(self, index, value): self.instruction_address[index] = value
    def get_module_name(self): return self.module_name
    def set_module_name(self, module_name): self.module_name = module_name
    def add_module_name(self, value): self.module_name.append(value)
    def insert_module_name_at(self, index, value): self.module_name.insert(index, value)
    def replace_module_name_at(self, index, value): self.module_name[index] = value
    def get_symbol_name(self): return self.symbol_name
    def set_symbol_name(self, symbol_name): self.symbol_name = symbol_name
    def add_symbol_name(self, value): self.symbol_name.append(value)
    def insert_symbol_name_at(self, index, value): self.symbol_name.insert(index, value)
    def replace_symbol_name_at(self, index, value): self.symbol_name[index] = value
    def get_symbol_displacement(self): return self.symbol_displacement
    def set_symbol_displacement(self, symbol_displacement): self.symbol_displacement = symbol_displacement
    def add_symbol_displacement(self, value): self.symbol_displacement.append(value)
    def insert_symbol_displacement_at(self, index, value): self.symbol_displacement.insert(index, value)
    def replace_symbol_displacement_at(self, index, value): self.symbol_displacement[index] = value
    def get_sequenceNumber(self): return self.sequenceNumber
    def set_sequenceNumber(self, sequenceNumber): self.sequenceNumber = sequenceNumber
    def hasContent_(self):
        if (
            self.frame_number or
            self.instruction_address or
            self.module_name or
            self.symbol_name or
            self.symbol_displacement
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='callstack-entry', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='callstack-entry')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='callstack-entry', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='callstack-entry'):
        if self.sequenceNumber is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            outfile.write(' sequenceNumber=%s' % (self.gds_format_string(quote_attrib(self.sequenceNumber).encode(ExternalEncoding), input_name='sequenceNumber'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='callstack-entry', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for frame_number_ in self.frame_number:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sframe-number>%s</%sframe-number>%s' % (namespace_, self.gds_format_string(quote_xml(frame_number_).encode(ExternalEncoding), input_name='frame-number'), namespace_, eol_))
        for instruction_address_ in self.instruction_address:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinstruction-address>%s</%sinstruction-address>%s' % (namespace_, self.gds_format_string(quote_xml(instruction_address_).encode(ExternalEncoding), input_name='instruction-address'), namespace_, eol_))
        for module_name_ in self.module_name:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smodule-name>%s</%smodule-name>%s' % (namespace_, self.gds_format_string(quote_xml(module_name_).encode(ExternalEncoding), input_name='module-name'), namespace_, eol_))
        for symbol_name_ in self.symbol_name:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssymbol-name>%s</%ssymbol-name>%s' % (namespace_, self.gds_format_string(quote_xml(symbol_name_).encode(ExternalEncoding), input_name='symbol-name'), namespace_, eol_))
        for symbol_displacement_ in self.symbol_displacement:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssymbol-displacement>%s</%ssymbol-displacement>%s' % (namespace_, self.gds_format_string(quote_xml(symbol_displacement_).encode(ExternalEncoding), input_name='symbol-displacement'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='callstack-entry'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.sequenceNumber is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            showIndent(outfile, level)
            outfile.write('sequenceNumber="%s",\n' % (self.sequenceNumber,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('frame_number=[\n')
        level += 1
        for frame_number_ in self.frame_number:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(frame_number_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('instruction_address=[\n')
        level += 1
        for instruction_address_ in self.instruction_address:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(instruction_address_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('module_name=[\n')
        level += 1
        for module_name_ in self.module_name:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(module_name_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('symbol_name=[\n')
        level += 1
        for symbol_name_ in self.symbol_name:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(symbol_name_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('symbol_displacement=[\n')
        level += 1
        for symbol_displacement_ in self.symbol_displacement:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(symbol_displacement_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sequenceNumber', node)
        if value is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            self.sequenceNumber = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'frame-number':
            frame_number_ = child_.text
            frame_number_ = self.gds_validate_string(frame_number_, node, 'frame_number')
            self.frame_number.append(frame_number_)
        elif nodeName_ == 'instruction-address':
            instruction_address_ = child_.text
            instruction_address_ = self.gds_validate_string(instruction_address_, node, 'instruction_address')
            self.instruction_address.append(instruction_address_)
        elif nodeName_ == 'module-name':
            module_name_ = child_.text
            module_name_ = self.gds_validate_string(module_name_, node, 'module_name')
            self.module_name.append(module_name_)
        elif nodeName_ == 'symbol-name':
            symbol_name_ = child_.text
            symbol_name_ = self.gds_validate_string(symbol_name_, node, 'symbol_name')
            self.symbol_name.append(symbol_name_)
        elif nodeName_ == 'symbol-displacement':
            symbol_displacement_ = child_.text
            symbol_displacement_ = self.gds_validate_string(symbol_displacement_, node, 'symbol_displacement')
            self.symbol_displacement.append(symbol_displacement_)
# end class callstack_entry


class fid(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ads=None, sequenceNumber=None, valueOf_=None):
        self.original_tagname_ = None
        self.ads = _cast(None, ads)
        self.sequenceNumber = _cast(None, sequenceNumber)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if fid.subclass:
            return fid.subclass(*args_, **kwargs_)
        else:
            return fid(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ads(self): return self.ads
    def set_ads(self, ads): self.ads = ads
    def get_sequenceNumber(self): return self.sequenceNumber
    def set_sequenceNumber(self, sequenceNumber): self.sequenceNumber = sequenceNumber
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='fid', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='fid')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='fid', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='fid'):
        if self.ads is not None and 'ads' not in already_processed:
            already_processed.add('ads')
            outfile.write(' ads=%s' % (self.gds_format_string(quote_attrib(self.ads).encode(ExternalEncoding), input_name='ads'), ))
        if self.sequenceNumber is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            outfile.write(' sequenceNumber=%s' % (self.gds_format_string(quote_attrib(self.sequenceNumber).encode(ExternalEncoding), input_name='sequenceNumber'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='fid', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='fid'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ads is not None and 'ads' not in already_processed:
            already_processed.add('ads')
            showIndent(outfile, level)
            outfile.write('ads="%s",\n' % (self.ads,))
        if self.sequenceNumber is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            showIndent(outfile, level)
            outfile.write('sequenceNumber="%s",\n' % (self.sequenceNumber,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ads', node)
        if value is not None and 'ads' not in already_processed:
            already_processed.add('ads')
            self.ads = value
        value = find_attr_value_('sequenceNumber', node)
        if value is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            self.sequenceNumber = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class fid


class appexception(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, sequenceNumber=None, processinfo=None, exception_faulting_address=None, exception_code=None, exception_level=None, exception_type=None, instruction_address=None, description=None, classification=None, bug_title=None):
        self.original_tagname_ = None
        self.sequenceNumber = _cast(None, sequenceNumber)
        self.processinfo = processinfo
        self.exception_faulting_address = exception_faulting_address
        self.exception_code = exception_code
        self.exception_level = exception_level
        self.exception_type = exception_type
        self.instruction_address = instruction_address
        self.description = description
        self.classification = classification
        self.bug_title = bug_title
    def factory(*args_, **kwargs_):
        if appexception.subclass:
            return appexception.subclass(*args_, **kwargs_)
        else:
            return appexception(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_processinfo(self): return self.processinfo
    def set_processinfo(self, processinfo): self.processinfo = processinfo
    def get_exception_faulting_address(self): return self.exception_faulting_address
    def set_exception_faulting_address(self, exception_faulting_address): self.exception_faulting_address = exception_faulting_address
    def get_exception_code(self): return self.exception_code
    def set_exception_code(self, exception_code): self.exception_code = exception_code
    def get_exception_level(self): return self.exception_level
    def set_exception_level(self, exception_level): self.exception_level = exception_level
    def get_exception_type(self): return self.exception_type
    def set_exception_type(self, exception_type): self.exception_type = exception_type
    def get_instruction_address(self): return self.instruction_address
    def set_instruction_address(self, instruction_address): self.instruction_address = instruction_address
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_classification(self): return self.classification
    def set_classification(self, classification): self.classification = classification
    def get_bug_title(self): return self.bug_title
    def set_bug_title(self, bug_title): self.bug_title = bug_title
    def get_sequenceNumber(self): return self.sequenceNumber
    def set_sequenceNumber(self, sequenceNumber): self.sequenceNumber = sequenceNumber
    def hasContent_(self):
        if (
            self.processinfo is not None or
            self.exception_faulting_address is not None or
            self.exception_code is not None or
            self.exception_level is not None or
            self.exception_type is not None or
            self.instruction_address is not None or
            self.description is not None or
            self.classification is not None or
            self.bug_title is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='appexception', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='appexception')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='appexception', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='appexception'):
        if self.sequenceNumber is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            outfile.write(' sequenceNumber=%s' % (self.gds_format_string(quote_attrib(self.sequenceNumber).encode(ExternalEncoding), input_name='sequenceNumber'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='appexception', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.processinfo is not None:
            self.processinfo.export(outfile, level, namespace_, name_='processinfo', pretty_print=pretty_print)
        if self.exception_faulting_address is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sexception_faulting_address>%s</%sexception_faulting_address>%s' % (namespace_, self.gds_format_string(quote_xml(self.exception_faulting_address).encode(ExternalEncoding), input_name='exception_faulting_address'), namespace_, eol_))
        if self.exception_code is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sexception_code>%s</%sexception_code>%s' % (namespace_, self.gds_format_string(quote_xml(self.exception_code).encode(ExternalEncoding), input_name='exception_code'), namespace_, eol_))
        if self.exception_level is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sexception_level>%s</%sexception_level>%s' % (namespace_, self.gds_format_string(quote_xml(self.exception_level).encode(ExternalEncoding), input_name='exception_level'), namespace_, eol_))
        if self.exception_type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sexception_type>%s</%sexception_type>%s' % (namespace_, self.gds_format_string(quote_xml(self.exception_type).encode(ExternalEncoding), input_name='exception_type'), namespace_, eol_))
        if self.instruction_address is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinstruction_address>%s</%sinstruction_address>%s' % (namespace_, self.gds_format_string(quote_xml(self.instruction_address).encode(ExternalEncoding), input_name='instruction_address'), namespace_, eol_))
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.description).encode(ExternalEncoding), input_name='description'), namespace_, eol_))
        if self.classification is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sclassification>%s</%sclassification>%s' % (namespace_, self.gds_format_string(quote_xml(self.classification).encode(ExternalEncoding), input_name='classification'), namespace_, eol_))
        if self.bug_title is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbug_title>%s</%sbug_title>%s' % (namespace_, self.gds_format_string(quote_xml(self.bug_title).encode(ExternalEncoding), input_name='bug_title'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='appexception'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.sequenceNumber is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            showIndent(outfile, level)
            outfile.write('sequenceNumber="%s",\n' % (self.sequenceNumber,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.processinfo is not None:
            showIndent(outfile, level)
            outfile.write('processinfo=model_.processinfo(\n')
            self.processinfo.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.exception_faulting_address is not None:
            showIndent(outfile, level)
            outfile.write('exception_faulting_address=%s,\n' % quote_python(self.exception_faulting_address).encode(ExternalEncoding))
        if self.exception_code is not None:
            showIndent(outfile, level)
            outfile.write('exception_code=%s,\n' % quote_python(self.exception_code).encode(ExternalEncoding))
        if self.exception_level is not None:
            showIndent(outfile, level)
            outfile.write('exception_level=%s,\n' % quote_python(self.exception_level).encode(ExternalEncoding))
        if self.exception_type is not None:
            showIndent(outfile, level)
            outfile.write('exception_type=%s,\n' % quote_python(self.exception_type).encode(ExternalEncoding))
        if self.instruction_address is not None:
            showIndent(outfile, level)
            outfile.write('instruction_address=%s,\n' % quote_python(self.instruction_address).encode(ExternalEncoding))
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=%s,\n' % quote_python(self.description).encode(ExternalEncoding))
        if self.classification is not None:
            showIndent(outfile, level)
            outfile.write('classification=%s,\n' % quote_python(self.classification).encode(ExternalEncoding))
        if self.bug_title is not None:
            showIndent(outfile, level)
            outfile.write('bug_title=%s,\n' % quote_python(self.bug_title).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sequenceNumber', node)
        if value is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            self.sequenceNumber = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'processinfo':
            obj_ = processinfo.factory()
            obj_.build(child_)
            self.processinfo = obj_
            obj_.original_tagname_ = 'processinfo'
        elif nodeName_ == 'exception_faulting_address':
            exception_faulting_address_ = child_.text
            exception_faulting_address_ = self.gds_validate_string(exception_faulting_address_, node, 'exception_faulting_address')
            self.exception_faulting_address = exception_faulting_address_
        elif nodeName_ == 'exception_code':
            exception_code_ = child_.text
            exception_code_ = self.gds_validate_string(exception_code_, node, 'exception_code')
            self.exception_code = exception_code_
        elif nodeName_ == 'exception_level':
            exception_level_ = child_.text
            exception_level_ = self.gds_validate_string(exception_level_, node, 'exception_level')
            self.exception_level = exception_level_
        elif nodeName_ == 'exception_type':
            exception_type_ = child_.text
            exception_type_ = self.gds_validate_string(exception_type_, node, 'exception_type')
            self.exception_type = exception_type_
        elif nodeName_ == 'instruction_address':
            instruction_address_ = child_.text
            instruction_address_ = self.gds_validate_string(instruction_address_, node, 'instruction_address')
            self.instruction_address = instruction_address_
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'classification':
            classification_ = child_.text
            classification_ = self.gds_validate_string(classification_, node, 'classification')
            self.classification = classification_
        elif nodeName_ == 'bug_title':
            bug_title_ = child_.text
            bug_title_ = self.gds_validate_string(bug_title_, node, 'bug_title')
            self.bug_title = bug_title_
# end class appexception


class debugcontrol(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, sequenceNumber=None, processinfo=None, controlcode=None, codedescription=None):
        self.original_tagname_ = None
        self.sequenceNumber = _cast(None, sequenceNumber)
        self.processinfo = processinfo
        self.controlcode = controlcode
        self.codedescription = codedescription
    def factory(*args_, **kwargs_):
        if debugcontrol.subclass:
            return debugcontrol.subclass(*args_, **kwargs_)
        else:
            return debugcontrol(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_processinfo(self): return self.processinfo
    def set_processinfo(self, processinfo): self.processinfo = processinfo
    def get_controlcode(self): return self.controlcode
    def set_controlcode(self, controlcode): self.controlcode = controlcode
    def get_codedescription(self): return self.codedescription
    def set_codedescription(self, codedescription): self.codedescription = codedescription
    def get_sequenceNumber(self): return self.sequenceNumber
    def set_sequenceNumber(self, sequenceNumber): self.sequenceNumber = sequenceNumber
    def hasContent_(self):
        if (
            self.processinfo is not None or
            self.controlcode is not None or
            self.codedescription is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='debugcontrol', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='debugcontrol')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='debugcontrol', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='debugcontrol'):
        if self.sequenceNumber is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            outfile.write(' sequenceNumber=%s' % (self.gds_format_string(quote_attrib(self.sequenceNumber).encode(ExternalEncoding), input_name='sequenceNumber'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='debugcontrol', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.processinfo is not None:
            self.processinfo.export(outfile, level, namespace_, name_='processinfo', pretty_print=pretty_print)
        if self.controlcode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scontrolcode>%s</%scontrolcode>%s' % (namespace_, self.gds_format_string(quote_xml(self.controlcode).encode(ExternalEncoding), input_name='controlcode'), namespace_, eol_))
        if self.codedescription is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scodedescription>%s</%scodedescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.codedescription).encode(ExternalEncoding), input_name='codedescription'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='debugcontrol'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.sequenceNumber is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            showIndent(outfile, level)
            outfile.write('sequenceNumber="%s",\n' % (self.sequenceNumber,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.processinfo is not None:
            showIndent(outfile, level)
            outfile.write('processinfo=model_.processinfo(\n')
            self.processinfo.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.controlcode is not None:
            showIndent(outfile, level)
            outfile.write('controlcode=%s,\n' % quote_python(self.controlcode).encode(ExternalEncoding))
        if self.codedescription is not None:
            showIndent(outfile, level)
            outfile.write('codedescription=%s,\n' % quote_python(self.codedescription).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sequenceNumber', node)
        if value is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            self.sequenceNumber = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'processinfo':
            obj_ = processinfo.factory()
            obj_.build(child_)
            self.processinfo = obj_
            obj_.original_tagname_ = 'processinfo'
        elif nodeName_ == 'controlcode':
            controlcode_ = child_.text
            controlcode_ = self.gds_validate_string(controlcode_, node, 'controlcode')
            self.controlcode = controlcode_
        elif nodeName_ == 'codedescription':
            codedescription_ = child_.text
            codedescription_ = self.gds_validate_string(codedescription_, node, 'codedescription')
            self.codedescription = codedescription_
# end class debugcontrol


class hiddenproc(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, mode=None, sequenceNumber=None, processinfo=None, imagename=None):
        self.original_tagname_ = None
        self.mode = _cast(None, mode)
        self.sequenceNumber = _cast(None, sequenceNumber)
        self.processinfo = processinfo
        self.imagename = imagename
    def factory(*args_, **kwargs_):
        if hiddenproc.subclass:
            return hiddenproc.subclass(*args_, **kwargs_)
        else:
            return hiddenproc(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_processinfo(self): return self.processinfo
    def set_processinfo(self, processinfo): self.processinfo = processinfo
    def get_imagename(self): return self.imagename
    def set_imagename(self, imagename): self.imagename = imagename
    def get_mode(self): return self.mode
    def set_mode(self, mode): self.mode = mode
    def get_sequenceNumber(self): return self.sequenceNumber
    def set_sequenceNumber(self, sequenceNumber): self.sequenceNumber = sequenceNumber
    def hasContent_(self):
        if (
            self.processinfo is not None or
            self.imagename is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='hiddenproc', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='hiddenproc')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='hiddenproc', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='hiddenproc'):
        if self.mode is not None and 'mode' not in already_processed:
            already_processed.add('mode')
            outfile.write(' mode=%s' % (self.gds_format_string(quote_attrib(self.mode).encode(ExternalEncoding), input_name='mode'), ))
        if self.sequenceNumber is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            outfile.write(' sequenceNumber=%s' % (self.gds_format_string(quote_attrib(self.sequenceNumber).encode(ExternalEncoding), input_name='sequenceNumber'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='hiddenproc', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.processinfo is not None:
            self.processinfo.export(outfile, level, namespace_, name_='processinfo', pretty_print=pretty_print)
        if self.imagename is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%simagename>%s</%simagename>%s' % (namespace_, self.gds_format_string(quote_xml(self.imagename).encode(ExternalEncoding), input_name='imagename'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='hiddenproc'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.mode is not None and 'mode' not in already_processed:
            already_processed.add('mode')
            showIndent(outfile, level)
            outfile.write('mode="%s",\n' % (self.mode,))
        if self.sequenceNumber is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            showIndent(outfile, level)
            outfile.write('sequenceNumber="%s",\n' % (self.sequenceNumber,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.processinfo is not None:
            showIndent(outfile, level)
            outfile.write('processinfo=model_.processinfo(\n')
            self.processinfo.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.imagename is not None:
            showIndent(outfile, level)
            outfile.write('imagename=%s,\n' % quote_python(self.imagename).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('mode', node)
        if value is not None and 'mode' not in already_processed:
            already_processed.add('mode')
            self.mode = value
        value = find_attr_value_('sequenceNumber', node)
        if value is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            self.sequenceNumber = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'processinfo':
            obj_ = processinfo.factory()
            obj_.build(child_)
            self.processinfo = obj_
            obj_.original_tagname_ = 'processinfo'
        elif nodeName_ == 'imagename':
            imagename_ = child_.text
            imagename_ = self.gds_validate_string(imagename_, node, 'imagename')
            self.imagename = imagename_
# end class hiddenproc


class dll_exports(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, sequenceNumber=None, dllname=None, exports=None):
        self.original_tagname_ = None
        self.sequenceNumber = _cast(None, sequenceNumber)
        self.dllname = dllname
        self.exports = exports
    def factory(*args_, **kwargs_):
        if dll_exports.subclass:
            return dll_exports.subclass(*args_, **kwargs_)
        else:
            return dll_exports(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dllname(self): return self.dllname
    def set_dllname(self, dllname): self.dllname = dllname
    def get_exports(self): return self.exports
    def set_exports(self, exports): self.exports = exports
    def get_sequenceNumber(self): return self.sequenceNumber
    def set_sequenceNumber(self, sequenceNumber): self.sequenceNumber = sequenceNumber
    def hasContent_(self):
        if (
            self.dllname is not None or
            self.exports is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='dll-exports', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='dll-exports')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='dll-exports', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='dll-exports'):
        if self.sequenceNumber is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            outfile.write(' sequenceNumber=%s' % (self.gds_format_string(quote_attrib(self.sequenceNumber).encode(ExternalEncoding), input_name='sequenceNumber'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='dll-exports', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.dllname is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdllname>%s</%sdllname>%s' % (namespace_, self.gds_format_string(quote_xml(self.dllname).encode(ExternalEncoding), input_name='dllname'), namespace_, eol_))
        if self.exports is not None:
            self.exports.export(outfile, level, namespace_, name_='exports', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='dll-exports'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.sequenceNumber is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            showIndent(outfile, level)
            outfile.write('sequenceNumber="%s",\n' % (self.sequenceNumber,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.dllname is not None:
            showIndent(outfile, level)
            outfile.write('dllname=%s,\n' % quote_python(self.dllname).encode(ExternalEncoding))
        if self.exports is not None:
            showIndent(outfile, level)
            outfile.write('exports=model_.exports(\n')
            self.exports.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sequenceNumber', node)
        if value is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            self.sequenceNumber = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'dllname':
            dllname_ = child_.text
            dllname_ = self.gds_validate_string(dllname_, node, 'dllname')
            self.dllname = dllname_
        elif nodeName_ == 'exports':
            obj_ = exports.factory()
            obj_.build(child_)
            self.exports = obj_
            obj_.original_tagname_ = 'exports'
# end class dll_exports


class exports(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, sequenceNumber=None, export_function=None):
        self.original_tagname_ = None
        self.sequenceNumber = _cast(None, sequenceNumber)
        if export_function is None:
            self.export_function = []
        else:
            self.export_function = export_function
    def factory(*args_, **kwargs_):
        if exports.subclass:
            return exports.subclass(*args_, **kwargs_)
        else:
            return exports(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_export_function(self): return self.export_function
    def set_export_function(self, export_function): self.export_function = export_function
    def add_export_function(self, value): self.export_function.append(value)
    def insert_export_function_at(self, index, value): self.export_function.insert(index, value)
    def replace_export_function_at(self, index, value): self.export_function[index] = value
    def get_sequenceNumber(self): return self.sequenceNumber
    def set_sequenceNumber(self, sequenceNumber): self.sequenceNumber = sequenceNumber
    def hasContent_(self):
        if (
            self.export_function
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='exports', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='exports')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='exports', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='exports'):
        if self.sequenceNumber is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            outfile.write(' sequenceNumber=%s' % (self.gds_format_string(quote_attrib(self.sequenceNumber).encode(ExternalEncoding), input_name='sequenceNumber'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='exports', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for export_function_ in self.export_function:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sexport-function>%s</%sexport-function>%s' % (namespace_, self.gds_format_string(quote_xml(export_function_).encode(ExternalEncoding), input_name='export-function'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='exports'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.sequenceNumber is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            showIndent(outfile, level)
            outfile.write('sequenceNumber="%s",\n' % (self.sequenceNumber,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('export_function=[\n')
        level += 1
        for export_function_ in self.export_function:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(export_function_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sequenceNumber', node)
        if value is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            self.sequenceNumber = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'export-function':
            export_function_ = child_.text
            export_function_ = self.gds_validate_string(export_function_, node, 'export_function')
            self.export_function.append(export_function_)
# end class exports


class AsyncKeyLogger(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, sequenceNumber=None, processinfo=None, ProbePattern=None, Yields=None, Probes=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
        self.sequenceNumber = _cast(None, sequenceNumber)
        self.processinfo = processinfo
        self.ProbePattern = ProbePattern
        self.Yields = Yields
        self.Probes = Probes
    def factory(*args_, **kwargs_):
        if AsyncKeyLogger.subclass:
            return AsyncKeyLogger.subclass(*args_, **kwargs_)
        else:
            return AsyncKeyLogger(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_processinfo(self): return self.processinfo
    def set_processinfo(self, processinfo): self.processinfo = processinfo
    def get_ProbePattern(self): return self.ProbePattern
    def set_ProbePattern(self, ProbePattern): self.ProbePattern = ProbePattern
    def get_Yields(self): return self.Yields
    def set_Yields(self, Yields): self.Yields = Yields
    def get_Probes(self): return self.Probes
    def set_Probes(self, Probes): self.Probes = Probes
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_sequenceNumber(self): return self.sequenceNumber
    def set_sequenceNumber(self, sequenceNumber): self.sequenceNumber = sequenceNumber
    def hasContent_(self):
        if (
            self.processinfo is not None or
            self.ProbePattern is not None or
            self.Yields is not None or
            self.Probes is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AsyncKeyLogger', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AsyncKeyLogger')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AsyncKeyLogger', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AsyncKeyLogger'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.sequenceNumber is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            outfile.write(' sequenceNumber=%s' % (self.gds_format_string(quote_attrib(self.sequenceNumber).encode(ExternalEncoding), input_name='sequenceNumber'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='AsyncKeyLogger', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.processinfo is not None:
            self.processinfo.export(outfile, level, namespace_, name_='processinfo', pretty_print=pretty_print)
        if self.ProbePattern is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sProbePattern>%s</%sProbePattern>%s' % (namespace_, self.gds_format_string(quote_xml(self.ProbePattern).encode(ExternalEncoding), input_name='ProbePattern'), namespace_, eol_))
        if self.Yields is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sYields>%s</%sYields>%s' % (namespace_, self.gds_format_string(quote_xml(self.Yields).encode(ExternalEncoding), input_name='Yields'), namespace_, eol_))
        if self.Probes is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sProbes>%s</%sProbes>%s' % (namespace_, self.gds_format_string(quote_xml(self.Probes).encode(ExternalEncoding), input_name='Probes'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='AsyncKeyLogger'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.sequenceNumber is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            showIndent(outfile, level)
            outfile.write('sequenceNumber="%s",\n' % (self.sequenceNumber,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.processinfo is not None:
            showIndent(outfile, level)
            outfile.write('processinfo=model_.processinfo(\n')
            self.processinfo.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ProbePattern is not None:
            showIndent(outfile, level)
            outfile.write('ProbePattern=%s,\n' % quote_python(self.ProbePattern).encode(ExternalEncoding))
        if self.Yields is not None:
            showIndent(outfile, level)
            outfile.write('Yields=%s,\n' % quote_python(self.Yields).encode(ExternalEncoding))
        if self.Probes is not None:
            showIndent(outfile, level)
            outfile.write('Probes=%s,\n' % quote_python(self.Probes).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('sequenceNumber', node)
        if value is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            self.sequenceNumber = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'processinfo':
            obj_ = processinfo.factory()
            obj_.build(child_)
            self.processinfo = obj_
            obj_.original_tagname_ = 'processinfo'
        elif nodeName_ == 'ProbePattern':
            ProbePattern_ = child_.text
            ProbePattern_ = self.gds_validate_string(ProbePattern_, node, 'ProbePattern')
            self.ProbePattern = ProbePattern_
        elif nodeName_ == 'Yields':
            Yields_ = child_.text
            Yields_ = self.gds_validate_string(Yields_, node, 'Yields')
            self.Yields = Yields_
        elif nodeName_ == 'Probes':
            Probes_ = child_.text
            Probes_ = self.gds_validate_string(Probes_, node, 'Probes')
            self.Probes = Probes_
# end class AsyncKeyLogger


class CmdLine(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, sequenceNumber=None, value=None, ExitCode=None):
        self.original_tagname_ = None
        self.sequenceNumber = _cast(None, sequenceNumber)
        self.value = value
        self.ExitCode = ExitCode
    def factory(*args_, **kwargs_):
        if CmdLine.subclass:
            return CmdLine.subclass(*args_, **kwargs_)
        else:
            return CmdLine(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_ExitCode(self): return self.ExitCode
    def set_ExitCode(self, ExitCode): self.ExitCode = ExitCode
    def get_sequenceNumber(self): return self.sequenceNumber
    def set_sequenceNumber(self, sequenceNumber): self.sequenceNumber = sequenceNumber
    def hasContent_(self):
        if (
            self.value is not None or
            self.ExitCode is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CmdLine', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CmdLine')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CmdLine', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CmdLine'):
        if self.sequenceNumber is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            outfile.write(' sequenceNumber=%s' % (self.gds_format_string(quote_attrib(self.sequenceNumber).encode(ExternalEncoding), input_name='sequenceNumber'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CmdLine', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_string(quote_xml(self.value).encode(ExternalEncoding), input_name='value'), namespace_, eol_))
        if self.ExitCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sExitCode>%s</%sExitCode>%s' % (namespace_, self.gds_format_string(quote_xml(self.ExitCode).encode(ExternalEncoding), input_name='ExitCode'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='CmdLine'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.sequenceNumber is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            showIndent(outfile, level)
            outfile.write('sequenceNumber="%s",\n' % (self.sequenceNumber,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=%s,\n' % quote_python(self.value).encode(ExternalEncoding))
        if self.ExitCode is not None:
            showIndent(outfile, level)
            outfile.write('ExitCode=%s,\n' % quote_python(self.ExitCode).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sequenceNumber', node)
        if value is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            self.sequenceNumber = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value = value_
        elif nodeName_ == 'ExitCode':
            ExitCode_ = child_.text
            ExitCode_ = self.gds_validate_string(ExitCode_, node, 'ExitCode')
            self.ExitCode = ExitCode_
# end class CmdLine


class spooler_dll_injection(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, sequenceNumber=None, processinfo=None, dllname=None, apiname=None, address=None, params=None):
        self.original_tagname_ = None
        self.sequenceNumber = _cast(None, sequenceNumber)
        self.processinfo = processinfo
        self.dllname = dllname
        self.apiname = apiname
        self.address = address
        self.params = params
    def factory(*args_, **kwargs_):
        if spooler_dll_injection.subclass:
            return spooler_dll_injection.subclass(*args_, **kwargs_)
        else:
            return spooler_dll_injection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_processinfo(self): return self.processinfo
    def set_processinfo(self, processinfo): self.processinfo = processinfo
    def get_dllname(self): return self.dllname
    def set_dllname(self, dllname): self.dllname = dllname
    def get_apiname(self): return self.apiname
    def set_apiname(self, apiname): self.apiname = apiname
    def get_address(self): return self.address
    def set_address(self, address): self.address = address
    def get_params(self): return self.params
    def set_params(self, params): self.params = params
    def get_sequenceNumber(self): return self.sequenceNumber
    def set_sequenceNumber(self, sequenceNumber): self.sequenceNumber = sequenceNumber
    def hasContent_(self):
        if (
            self.processinfo is not None or
            self.dllname is not None or
            self.apiname is not None or
            self.address is not None or
            self.params is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='spooler-dll-injection', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='spooler-dll-injection')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='spooler-dll-injection', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='spooler-dll-injection'):
        if self.sequenceNumber is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            outfile.write(' sequenceNumber=%s' % (self.gds_format_string(quote_attrib(self.sequenceNumber).encode(ExternalEncoding), input_name='sequenceNumber'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='spooler-dll-injection', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.processinfo is not None:
            self.processinfo.export(outfile, level, namespace_, name_='processinfo', pretty_print=pretty_print)
        if self.dllname is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdllname>%s</%sdllname>%s' % (namespace_, self.gds_format_string(quote_xml(self.dllname).encode(ExternalEncoding), input_name='dllname'), namespace_, eol_))
        if self.apiname is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sapiname>%s</%sapiname>%s' % (namespace_, self.gds_format_string(quote_xml(self.apiname).encode(ExternalEncoding), input_name='apiname'), namespace_, eol_))
        if self.address is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saddress>%s</%saddress>%s' % (namespace_, self.gds_format_string(quote_xml(self.address).encode(ExternalEncoding), input_name='address'), namespace_, eol_))
        if self.params is not None:
            self.params.export(outfile, level, namespace_, name_='params', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='spooler-dll-injection'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.sequenceNumber is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            showIndent(outfile, level)
            outfile.write('sequenceNumber="%s",\n' % (self.sequenceNumber,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.processinfo is not None:
            showIndent(outfile, level)
            outfile.write('processinfo=model_.processinfo(\n')
            self.processinfo.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.dllname is not None:
            showIndent(outfile, level)
            outfile.write('dllname=%s,\n' % quote_python(self.dllname).encode(ExternalEncoding))
        if self.apiname is not None:
            showIndent(outfile, level)
            outfile.write('apiname=%s,\n' % quote_python(self.apiname).encode(ExternalEncoding))
        if self.address is not None:
            showIndent(outfile, level)
            outfile.write('address=%s,\n' % quote_python(self.address).encode(ExternalEncoding))
        if self.params is not None:
            showIndent(outfile, level)
            outfile.write('params=model_.params(\n')
            self.params.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sequenceNumber', node)
        if value is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            self.sequenceNumber = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'processinfo':
            obj_ = processinfo.factory()
            obj_.build(child_)
            self.processinfo = obj_
            obj_.original_tagname_ = 'processinfo'
        elif nodeName_ == 'dllname':
            dllname_ = child_.text
            dllname_ = self.gds_validate_string(dllname_, node, 'dllname')
            self.dllname = dllname_
        elif nodeName_ == 'apiname':
            apiname_ = child_.text
            apiname_ = self.gds_validate_string(apiname_, node, 'apiname')
            self.apiname = apiname_
        elif nodeName_ == 'address':
            address_ = child_.text
            address_ = self.gds_validate_string(address_, node, 'address')
            self.address = address_
        elif nodeName_ == 'params':
            obj_ = params.factory()
            obj_.build(child_)
            self.params = obj_
            obj_.original_tagname_ = 'params'
# end class spooler_dll_injection


class firefox(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, mode=None, sequenceNumber=None, old_homepage=None, new_homepage=None, pid=None):
        self.original_tagname_ = None
        self.mode = _cast(None, mode)
        self.sequenceNumber = _cast(None, sequenceNumber)
        self.old_homepage = old_homepage
        self.new_homepage = new_homepage
        self.pid = pid
    def factory(*args_, **kwargs_):
        if firefox.subclass:
            return firefox.subclass(*args_, **kwargs_)
        else:
            return firefox(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_old_homepage(self): return self.old_homepage
    def set_old_homepage(self, old_homepage): self.old_homepage = old_homepage
    def get_new_homepage(self): return self.new_homepage
    def set_new_homepage(self, new_homepage): self.new_homepage = new_homepage
    def get_pid(self): return self.pid
    def set_pid(self, pid): self.pid = pid
    def get_mode(self): return self.mode
    def set_mode(self, mode): self.mode = mode
    def get_sequenceNumber(self): return self.sequenceNumber
    def set_sequenceNumber(self, sequenceNumber): self.sequenceNumber = sequenceNumber
    def hasContent_(self):
        if (
            self.old_homepage is not None or
            self.new_homepage is not None or
            self.pid is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='firefox', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='firefox')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='firefox', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='firefox'):
        if self.mode is not None and 'mode' not in already_processed:
            already_processed.add('mode')
            outfile.write(' mode=%s' % (self.gds_format_string(quote_attrib(self.mode).encode(ExternalEncoding), input_name='mode'), ))
        if self.sequenceNumber is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            outfile.write(' sequenceNumber=%s' % (self.gds_format_string(quote_attrib(self.sequenceNumber).encode(ExternalEncoding), input_name='sequenceNumber'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='firefox', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.old_homepage is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sold_homepage>%s</%sold_homepage>%s' % (namespace_, self.gds_format_string(quote_xml(self.old_homepage).encode(ExternalEncoding), input_name='old_homepage'), namespace_, eol_))
        if self.new_homepage is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snew_homepage>%s</%snew_homepage>%s' % (namespace_, self.gds_format_string(quote_xml(self.new_homepage).encode(ExternalEncoding), input_name='new_homepage'), namespace_, eol_))
        if self.pid is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spid>%s</%spid>%s' % (namespace_, self.gds_format_string(quote_xml(self.pid).encode(ExternalEncoding), input_name='pid'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='firefox'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.mode is not None and 'mode' not in already_processed:
            already_processed.add('mode')
            showIndent(outfile, level)
            outfile.write('mode="%s",\n' % (self.mode,))
        if self.sequenceNumber is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            showIndent(outfile, level)
            outfile.write('sequenceNumber="%s",\n' % (self.sequenceNumber,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.old_homepage is not None:
            showIndent(outfile, level)
            outfile.write('old_homepage=%s,\n' % quote_python(self.old_homepage).encode(ExternalEncoding))
        if self.new_homepage is not None:
            showIndent(outfile, level)
            outfile.write('new_homepage=%s,\n' % quote_python(self.new_homepage).encode(ExternalEncoding))
        if self.pid is not None:
            showIndent(outfile, level)
            outfile.write('pid=%s,\n' % quote_python(self.pid).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('mode', node)
        if value is not None and 'mode' not in already_processed:
            already_processed.add('mode')
            self.mode = value
        value = find_attr_value_('sequenceNumber', node)
        if value is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            self.sequenceNumber = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'old_homepage':
            old_homepage_ = child_.text
            old_homepage_ = self.gds_validate_string(old_homepage_, node, 'old_homepage')
            self.old_homepage = old_homepage_
        elif nodeName_ == 'new_homepage':
            new_homepage_ = child_.text
            new_homepage_ = self.gds_validate_string(new_homepage_, node, 'new_homepage')
            self.new_homepage = new_homepage_
        elif nodeName_ == 'pid':
            pid_ = child_.text
            pid_ = self.gds_validate_string(pid_, node, 'pid')
            self.pid = pid_
# end class firefox


class systemshutdown(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, sequenceNumber=None, processinfo=None, action=None, actiondescription=None):
        self.original_tagname_ = None
        self.sequenceNumber = _cast(None, sequenceNumber)
        self.processinfo = processinfo
        self.action = action
        self.actiondescription = actiondescription
    def factory(*args_, **kwargs_):
        if systemshutdown.subclass:
            return systemshutdown.subclass(*args_, **kwargs_)
        else:
            return systemshutdown(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_processinfo(self): return self.processinfo
    def set_processinfo(self, processinfo): self.processinfo = processinfo
    def get_action(self): return self.action
    def set_action(self, action): self.action = action
    def get_actiondescription(self): return self.actiondescription
    def set_actiondescription(self, actiondescription): self.actiondescription = actiondescription
    def get_sequenceNumber(self): return self.sequenceNumber
    def set_sequenceNumber(self, sequenceNumber): self.sequenceNumber = sequenceNumber
    def hasContent_(self):
        if (
            self.processinfo is not None or
            self.action is not None or
            self.actiondescription is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='systemshutdown', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='systemshutdown')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='systemshutdown', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='systemshutdown'):
        if self.sequenceNumber is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            outfile.write(' sequenceNumber=%s' % (self.gds_format_string(quote_attrib(self.sequenceNumber).encode(ExternalEncoding), input_name='sequenceNumber'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='systemshutdown', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.processinfo is not None:
            self.processinfo.export(outfile, level, namespace_, name_='processinfo', pretty_print=pretty_print)
        if self.action is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saction>%s</%saction>%s' % (namespace_, self.gds_format_string(quote_xml(self.action).encode(ExternalEncoding), input_name='action'), namespace_, eol_))
        if self.actiondescription is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sactiondescription>%s</%sactiondescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.actiondescription).encode(ExternalEncoding), input_name='actiondescription'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='systemshutdown'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.sequenceNumber is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            showIndent(outfile, level)
            outfile.write('sequenceNumber="%s",\n' % (self.sequenceNumber,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.processinfo is not None:
            showIndent(outfile, level)
            outfile.write('processinfo=model_.processinfo(\n')
            self.processinfo.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.action is not None:
            showIndent(outfile, level)
            outfile.write('action=%s,\n' % quote_python(self.action).encode(ExternalEncoding))
        if self.actiondescription is not None:
            showIndent(outfile, level)
            outfile.write('actiondescription=%s,\n' % quote_python(self.actiondescription).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sequenceNumber', node)
        if value is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            self.sequenceNumber = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'processinfo':
            obj_ = processinfo.factory()
            obj_.build(child_)
            self.processinfo = obj_
            obj_.original_tagname_ = 'processinfo'
        elif nodeName_ == 'action':
            action_ = child_.text
            action_ = self.gds_validate_string(action_, node, 'action')
            self.action = action_
        elif nodeName_ == 'actiondescription':
            actiondescription_ = child_.text
            actiondescription_ = self.gds_validate_string(actiondescription_, node, 'actiondescription')
            self.actiondescription = actiondescription_
# end class systemshutdown


class uac(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, mode=None, value=None, status=None, accountenabled=None, accountcreated=None, accountname=None, passwordchange=None, group=None, memberadded=None, memberremoved=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        self.mode = _cast(None, mode)
        self.value = value
        self.status = status
        self.accountenabled = accountenabled
        self.accountcreated = accountcreated
        self.accountname = accountname
        self.passwordchange = passwordchange
        self.group = group
        self.memberadded = memberadded
        self.memberremoved = memberremoved
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if uac.subclass:
            return uac.subclass(*args_, **kwargs_)
        else:
            return uac(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_accountenabled(self): return self.accountenabled
    def set_accountenabled(self, accountenabled): self.accountenabled = accountenabled
    def get_accountcreated(self): return self.accountcreated
    def set_accountcreated(self, accountcreated): self.accountcreated = accountcreated
    def get_accountname(self): return self.accountname
    def set_accountname(self, accountname): self.accountname = accountname
    def get_passwordchange(self): return self.passwordchange
    def set_passwordchange(self, passwordchange): self.passwordchange = passwordchange
    def get_group(self): return self.group
    def set_group(self, group): self.group = group
    def get_memberadded(self): return self.memberadded
    def set_memberadded(self, memberadded): self.memberadded = memberadded
    def get_memberremoved(self): return self.memberremoved
    def set_memberremoved(self, memberremoved): self.memberremoved = memberremoved
    def get_mode(self): return self.mode
    def set_mode(self, mode): self.mode = mode
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.value is not None or
            self.status is not None or
            self.accountenabled is not None or
            self.accountcreated is not None or
            self.accountname is not None or
            self.passwordchange is not None or
            self.group is not None or
            self.memberadded is not None or
            self.memberremoved is not None or
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='uac', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='uac')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='uac', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='uac'):
        if self.mode is not None and 'mode' not in already_processed:
            already_processed.add('mode')
            outfile.write(' mode=%s' % (self.gds_format_string(quote_attrib(self.mode).encode(ExternalEncoding), input_name='mode'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='uac', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='uac'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.mode is not None and 'mode' not in already_processed:
            already_processed.add('mode')
            showIndent(outfile, level)
            outfile.write('mode="%s",\n' % (self.mode,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('mode', node)
        if value is not None and 'mode' not in already_processed:
            already_processed.add('mode')
            self.mode = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'value' and child_.text is not None:
            valuestr_ = child_.text
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'value', valuestr_)
            self.content_.append(obj_)
        elif nodeName_ == 'status' and child_.text is not None:
            valuestr_ = child_.text
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'status', valuestr_)
            self.content_.append(obj_)
        elif nodeName_ == 'accountenabled' and child_.text is not None:
            valuestr_ = child_.text
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'accountenabled', valuestr_)
            self.content_.append(obj_)
        elif nodeName_ == 'accountcreated' and child_.text is not None:
            valuestr_ = child_.text
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'accountcreated', valuestr_)
            self.content_.append(obj_)
        elif nodeName_ == 'accountname' and child_.text is not None:
            valuestr_ = child_.text
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'accountname', valuestr_)
            self.content_.append(obj_)
        elif nodeName_ == 'passwordchange' and child_.text is not None:
            valuestr_ = child_.text
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'passwordchange', valuestr_)
            self.content_.append(obj_)
        elif nodeName_ == 'group' and child_.text is not None:
            valuestr_ = child_.text
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'group', valuestr_)
            self.content_.append(obj_)
        elif nodeName_ == 'memberadded' and child_.text is not None:
            valuestr_ = child_.text
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'memberadded', valuestr_)
            self.content_.append(obj_)
        elif nodeName_ == 'memberremoved' and child_.text is not None:
            valuestr_ = child_.text
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'memberremoved', valuestr_)
            self.content_.append(obj_)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class uac


class os_monitor(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, date=None, build_=None, sequenceNumber=None, time=None):
        self.original_tagname_ = None
        self.date = _cast(None, date)
        self.build_ = _cast(None, build_)
        self.sequenceNumber = _cast(None, sequenceNumber)
        self.time = _cast(None, time)
    def factory(*args_, **kwargs_):
        if os_monitor.subclass:
            return os_monitor.subclass(*args_, **kwargs_)
        else:
            return os_monitor(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_date(self): return self.date
    def set_date(self, date): self.date = date
    def get_build(self): return self.build_
    def set_build(self, build_): self.build_ = build_
    def get_sequenceNumber(self): return self.sequenceNumber
    def set_sequenceNumber(self, sequenceNumber): self.sequenceNumber = sequenceNumber
    def get_time(self): return self.time
    def set_time(self, time): self.time = time
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='os_monitor', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='os_monitor')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='os_monitor', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='os_monitor'):
        if self.date is not None and 'date' not in already_processed:
            already_processed.add('date')
            outfile.write(' date=%s' % (self.gds_format_string(quote_attrib(self.date).encode(ExternalEncoding), input_name='date'), ))
        if self.build_ is not None and 'build_' not in already_processed:
            already_processed.add('build_')
            outfile.write(' build=%s' % (self.gds_format_string(quote_attrib(self.build_).encode(ExternalEncoding), input_name='build'), ))
        if self.sequenceNumber is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            outfile.write(' sequenceNumber=%s' % (self.gds_format_string(quote_attrib(self.sequenceNumber).encode(ExternalEncoding), input_name='sequenceNumber'), ))
        if self.time is not None and 'time' not in already_processed:
            already_processed.add('time')
            outfile.write(' time=%s' % (self.gds_format_string(quote_attrib(self.time).encode(ExternalEncoding), input_name='time'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='os_monitor', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='os_monitor'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.date is not None and 'date' not in already_processed:
            already_processed.add('date')
            showIndent(outfile, level)
            outfile.write('date="%s",\n' % (self.date,))
        if self.build_ is not None and 'build_' not in already_processed:
            already_processed.add('build_')
            showIndent(outfile, level)
            outfile.write('build_="%s",\n' % (self.build_,))
        if self.sequenceNumber is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            showIndent(outfile, level)
            outfile.write('sequenceNumber="%s",\n' % (self.sequenceNumber,))
        if self.time is not None and 'time' not in already_processed:
            already_processed.add('time')
            showIndent(outfile, level)
            outfile.write('time="%s",\n' % (self.time,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('date', node)
        if value is not None and 'date' not in already_processed:
            already_processed.add('date')
            self.date = value
        value = find_attr_value_('build', node)
        if value is not None and 'build' not in already_processed:
            already_processed.add('build')
            self.build_ = value
        value = find_attr_value_('sequenceNumber', node)
        if value is not None and 'sequenceNumber' not in already_processed:
            already_processed.add('sequenceNumber')
            self.sequenceNumber = value
        value = find_attr_value_('time', node)
        if value is not None and 'time' not in already_processed:
            already_processed.add('time')
            self.time = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class os_monitor


class dstType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, mac=None, port=None, ip=None, smtp_to=None, smtp_cc=None):
        self.original_tagname_ = None
        self.mac = mac
        self.port = port
        self.ip = ip
        self.smtp_to = smtp_to
        self.smtp_cc = smtp_cc
    def factory(*args_, **kwargs_):
        if dstType.subclass:
            return dstType.subclass(*args_, **kwargs_)
        else:
            return dstType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_mac(self): return self.mac
    def set_mac(self, mac): self.mac = mac
    def get_port(self): return self.port
    def set_port(self, port): self.port = port
    def get_ip(self): return self.ip
    def set_ip(self, ip): self.ip = ip
    def get_smtp_to(self): return self.smtp_to
    def set_smtp_to(self, smtp_to): self.smtp_to = smtp_to
    def get_smtp_cc(self): return self.smtp_cc
    def set_smtp_cc(self, smtp_cc): self.smtp_cc = smtp_cc
    def hasContent_(self):
        if (
            self.mac is not None or
            self.port is not None or
            self.ip is not None or
            self.smtp_to is not None or
            self.smtp_cc is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='dstType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='dstType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='dstType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='dstType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='dstType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.mac is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smac>%s</%smac>%s' % (namespace_, self.gds_format_string(quote_xml(self.mac).encode(ExternalEncoding), input_name='mac'), namespace_, eol_))
        if self.port is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sport>%s</%sport>%s' % (namespace_, self.gds_format_string(quote_xml(self.port).encode(ExternalEncoding), input_name='port'), namespace_, eol_))
        if self.ip is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sip>%s</%sip>%s' % (namespace_, self.gds_format_string(quote_xml(self.ip).encode(ExternalEncoding), input_name='ip'), namespace_, eol_))
        if self.smtp_to is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssmtp-to>%s</%ssmtp-to>%s' % (namespace_, self.gds_format_string(quote_xml(self.smtp_to).encode(ExternalEncoding), input_name='smtp-to'), namespace_, eol_))
        if self.smtp_cc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssmtp-cc>%s</%ssmtp-cc>%s' % (namespace_, self.gds_format_string(quote_xml(self.smtp_cc).encode(ExternalEncoding), input_name='smtp-cc'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='dstType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.mac is not None:
            showIndent(outfile, level)
            outfile.write('mac=%s,\n' % quote_python(self.mac).encode(ExternalEncoding))
        if self.port is not None:
            showIndent(outfile, level)
            outfile.write('port=%s,\n' % quote_python(self.port).encode(ExternalEncoding))
        if self.ip is not None:
            showIndent(outfile, level)
            outfile.write('ip=%s,\n' % quote_python(self.ip).encode(ExternalEncoding))
        if self.smtp_to is not None:
            showIndent(outfile, level)
            outfile.write('smtp_to=%s,\n' % quote_python(self.smtp_to).encode(ExternalEncoding))
        if self.smtp_cc is not None:
            showIndent(outfile, level)
            outfile.write('smtp_cc=%s,\n' % quote_python(self.smtp_cc).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'mac':
            mac_ = child_.text
            mac_ = self.gds_validate_string(mac_, node, 'mac')
            self.mac = mac_
        elif nodeName_ == 'port':
            port_ = child_.text
            port_ = self.gds_validate_string(port_, node, 'port')
            self.port = port_
        elif nodeName_ == 'ip':
            ip_ = child_.text
            ip_ = self.gds_validate_string(ip_, node, 'ip')
            self.ip = ip_
        elif nodeName_ == 'smtp-to':
            smtp_to_ = child_.text
            smtp_to_ = self.gds_validate_string(smtp_to_, node, 'smtp_to')
            self.smtp_to = smtp_to_
        elif nodeName_ == 'smtp-cc':
            smtp_cc_ = child_.text
            smtp_cc_ = self.gds_validate_string(smtp_cc_, node, 'smtp_cc')
            self.smtp_cc = smtp_cc_
# end class dstType


class smtp_messageType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, subject=None, smtp_header=None, last_malware=None, protocol=None, date=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.subject = subject
        self.smtp_header = smtp_header
        self.last_malware = last_malware
        self.protocol = protocol
        self.date = date
    def factory(*args_, **kwargs_):
        if smtp_messageType.subclass:
            return smtp_messageType.subclass(*args_, **kwargs_)
        else:
            return smtp_messageType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_subject(self): return self.subject
    def set_subject(self, subject): self.subject = subject
    def get_smtp_header(self): return self.smtp_header
    def set_smtp_header(self, smtp_header): self.smtp_header = smtp_header
    def get_last_malware(self): return self.last_malware
    def set_last_malware(self, last_malware): self.last_malware = last_malware
    def get_protocol(self): return self.protocol
    def set_protocol(self, protocol): self.protocol = protocol
    def get_date(self): return self.date
    def set_date(self, date): self.date = date
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.subject is not None or
            self.smtp_header is not None or
            self.last_malware is not None or
            self.protocol is not None or
            self.date is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='smtp-messageType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='smtp-messageType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='smtp-messageType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='smtp-messageType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='smtp-messageType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.subject is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssubject>%s</%ssubject>%s' % (namespace_, self.gds_format_string(quote_xml(self.subject).encode(ExternalEncoding), input_name='subject'), namespace_, eol_))
        if self.smtp_header is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssmtp-header>%s</%ssmtp-header>%s' % (namespace_, self.gds_format_string(quote_xml(self.smtp_header).encode(ExternalEncoding), input_name='smtp-header'), namespace_, eol_))
        if self.last_malware is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slast-malware>%s</%slast-malware>%s' % (namespace_, self.gds_format_string(quote_xml(self.last_malware).encode(ExternalEncoding), input_name='last-malware'), namespace_, eol_))
        if self.protocol is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprotocol>%s</%sprotocol>%s' % (namespace_, self.gds_format_string(quote_xml(self.protocol).encode(ExternalEncoding), input_name='protocol'), namespace_, eol_))
        if self.date is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdate>%s</%sdate>%s' % (namespace_, self.gds_format_string(quote_xml(self.date).encode(ExternalEncoding), input_name='date'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='smtp-messageType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id="%s",\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.subject is not None:
            showIndent(outfile, level)
            outfile.write('subject=%s,\n' % quote_python(self.subject).encode(ExternalEncoding))
        if self.smtp_header is not None:
            showIndent(outfile, level)
            outfile.write('smtp_header=%s,\n' % quote_python(self.smtp_header).encode(ExternalEncoding))
        if self.last_malware is not None:
            showIndent(outfile, level)
            outfile.write('last_malware=%s,\n' % quote_python(self.last_malware).encode(ExternalEncoding))
        if self.protocol is not None:
            showIndent(outfile, level)
            outfile.write('protocol=%s,\n' % quote_python(self.protocol).encode(ExternalEncoding))
        if self.date is not None:
            showIndent(outfile, level)
            outfile.write('date=%s,\n' % quote_python(self.date).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'subject':
            subject_ = child_.text
            subject_ = self.gds_validate_string(subject_, node, 'subject')
            self.subject = subject_
        elif nodeName_ == 'smtp-header':
            smtp_header_ = child_.text
            smtp_header_ = self.gds_validate_string(smtp_header_, node, 'smtp_header')
            self.smtp_header = smtp_header_
        elif nodeName_ == 'last-malware':
            last_malware_ = child_.text
            last_malware_ = self.gds_validate_string(last_malware_, node, 'last_malware')
            self.last_malware = last_malware_
        elif nodeName_ == 'protocol':
            protocol_ = child_.text
            protocol_ = self.gds_validate_string(protocol_, node, 'protocol')
            self.protocol = protocol_
        elif nodeName_ == 'date':
            date_ = child_.text
            date_ = self.gds_validate_string(date_, node, 'date')
            self.date = date_
# end class smtp_messageType


class interfaceType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, mode=None, label=None, valueOf_=None):
        self.original_tagname_ = None
        self.mode = _cast(None, mode)
        self.label = _cast(None, label)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if interfaceType.subclass:
            return interfaceType.subclass(*args_, **kwargs_)
        else:
            return interfaceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_mode(self): return self.mode
    def set_mode(self, mode): self.mode = mode
    def get_label(self): return self.label
    def set_label(self, label): self.label = label
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_InterfaceMode(self, value):
        # Validate type InterfaceMode, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['inline', 'tap']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on InterfaceMode' % {"value" : value.encode("utf-8")} )
    def validate_InterfaceLabel(self, value):
        # Validate type InterfaceLabel, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['A', 'B', 'A1', 'B1', 'A2', 'B2']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on InterfaceLabel' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='interfaceType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='interfaceType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='interfaceType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='interfaceType'):
        if self.mode is not None and 'mode' not in already_processed:
            already_processed.add('mode')
            outfile.write(' mode=%s' % (quote_attrib(self.mode), ))
        if self.label is not None and 'label' not in already_processed:
            already_processed.add('label')
            outfile.write(' label=%s' % (quote_attrib(self.label), ))
    def exportChildren(self, outfile, level, namespace_='', name_='interfaceType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='interfaceType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.mode is not None and 'mode' not in already_processed:
            already_processed.add('mode')
            showIndent(outfile, level)
            outfile.write('mode="%s",\n' % (self.mode,))
        if self.label is not None and 'label' not in already_processed:
            already_processed.add('label')
            showIndent(outfile, level)
            outfile.write('label="%s",\n' % (self.label,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('mode', node)
        if value is not None and 'mode' not in already_processed:
            already_processed.add('mode')
            self.mode = value
            self.validate_InterfaceMode(self.mode)    # validate type InterfaceMode
        value = find_attr_value_('label', node)
        if value is not None and 'label' not in already_processed:
            already_processed.add('label')
            self.label = value
            self.validate_InterfaceLabel(self.label)    # validate type InterfaceLabel
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class interfaceType


class malware_detectedType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, malware=None):
        self.original_tagname_ = None
        if malware is None:
            self.malware = []
        else:
            self.malware = malware
    def factory(*args_, **kwargs_):
        if malware_detectedType.subclass:
            return malware_detectedType.subclass(*args_, **kwargs_)
        else:
            return malware_detectedType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_malware(self): return self.malware
    def set_malware(self, malware): self.malware = malware
    def add_malware(self, value): self.malware.append(value)
    def insert_malware_at(self, index, value): self.malware.insert(index, value)
    def replace_malware_at(self, index, value): self.malware[index] = value
    def hasContent_(self):
        if (
            self.malware
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='malware-detectedType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='malware-detectedType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='malware-detectedType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='malware-detectedType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='malware-detectedType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for malware_ in self.malware:
            malware_.export(outfile, level, namespace_, name_='malware', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='malware-detectedType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('malware=[\n')
        level += 1
        for malware_ in self.malware:
            showIndent(outfile, level)
            outfile.write('model_.malware(\n')
            malware_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'malware':
            obj_ = malware.factory()
            obj_.build(child_)
            self.malware.append(obj_)
            obj_.original_tagname_ = 'malware'
# end class malware_detectedType


class cnc_servicesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, cnc_service=None):
        self.original_tagname_ = None
        if cnc_service is None:
            self.cnc_service = []
        else:
            self.cnc_service = cnc_service
    def factory(*args_, **kwargs_):
        if cnc_servicesType.subclass:
            return cnc_servicesType.subclass(*args_, **kwargs_)
        else:
            return cnc_servicesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cnc_service(self): return self.cnc_service
    def set_cnc_service(self, cnc_service): self.cnc_service = cnc_service
    def add_cnc_service(self, value): self.cnc_service.append(value)
    def insert_cnc_service_at(self, index, value): self.cnc_service.insert(index, value)
    def replace_cnc_service_at(self, index, value): self.cnc_service[index] = value
    def hasContent_(self):
        if (
            self.cnc_service
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='cnc-servicesType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cnc-servicesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='cnc-servicesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='cnc-servicesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='cnc-servicesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for cnc_service_ in self.cnc_service:
            cnc_service_.export(outfile, level, namespace_, name_='cnc-service', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='cnc-servicesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('cnc_service=[\n')
        level += 1
        for cnc_service_ in self.cnc_service:
            showIndent(outfile, level)
            outfile.write('model_.cnc_service(\n')
            cnc_service_.exportLiteral(outfile, level, name_='cnc-service')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cnc-service':
            obj_ = cnc_service.factory()
            obj_.build(child_)
            self.cnc_service.append(obj_)
            obj_.original_tagname_ = 'cnc-service'
# end class cnc_servicesType


class os_changesType(OSCChangeSet):
    subclass = None
    superclass = OSCChangeSet
    def __init__(self, analysis=None, os=None, os_monitor=None, event_logger=None, apicall=None, application=None, codeinjection=None, driver=None, exploitcode=None, file=None, folder=None, heapspraying=None, malicious_alert=None, mutex=None, network=None, process=None, process_packed=None, processstats=None, regkey=None, uac=None, keyloggerdetected=None, HardwareAccessDetection=None, dll_loaded=None, appexception=None, debugcontrol=None, hiddenproc=None, dll_exports=None, guestos_not_pingable=None, SSDT=None, spooler_dll_injection=None, detection_monitor_killed=None, started=None, firefox=None, AsyncKeyLogger=None, CmdLine=None, systemshutdown=None, os_inactivity_send_keys=None, end_of_report=None, osinfo=None, version=None, id=None):
        self.original_tagname_ = None
        super(os_changesType, self).__init__(analysis, os, os_monitor, event_logger, apicall, application, codeinjection, driver, exploitcode, file, folder, heapspraying, malicious_alert, mutex, network, process, process_packed, processstats, regkey, uac, keyloggerdetected, HardwareAccessDetection, dll_loaded, appexception, debugcontrol, hiddenproc, dll_exports, guestos_not_pingable, SSDT, spooler_dll_injection, detection_monitor_killed, started, firefox, AsyncKeyLogger, CmdLine, systemshutdown, os_inactivity_send_keys, end_of_report, )
        self.osinfo = _cast(None, osinfo)
        self.version = _cast(None, version)
        self.id = _cast(int, id)
    def factory(*args_, **kwargs_):
        if os_changesType.subclass:
            return os_changesType.subclass(*args_, **kwargs_)
        else:
            return os_changesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_osinfo(self): return self.osinfo
    def set_osinfo(self, osinfo): self.osinfo = osinfo
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            super(os_changesType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='os-changesType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='os-changesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='os-changesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='os-changesType'):
        super(os_changesType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='os-changesType')
        if self.osinfo is not None and 'osinfo' not in already_processed:
            already_processed.add('osinfo')
            outfile.write(' osinfo=%s' % (self.gds_format_string(quote_attrib(self.osinfo).encode(ExternalEncoding), input_name='osinfo'), ))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (self.gds_format_string(quote_attrib(self.version).encode(ExternalEncoding), input_name='version'), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id="%s"' % self.gds_format_integer(self.id, input_name='id'))
    def exportChildren(self, outfile, level, namespace_='', name_='os-changesType', fromsubclass_=False, pretty_print=True):
        super(os_changesType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='os-changesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.osinfo is not None and 'osinfo' not in already_processed:
            already_processed.add('osinfo')
            showIndent(outfile, level)
            outfile.write('osinfo="%s",\n' % (self.osinfo,))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            showIndent(outfile, level)
            outfile.write('version="%s",\n' % (self.version,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id=%d,\n' % (self.id,))
        super(os_changesType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(os_changesType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('osinfo', node)
        if value is not None and 'osinfo' not in already_processed:
            already_processed.add('osinfo')
            self.osinfo = value
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            try:
                self.id = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        super(os_changesType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(os_changesType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class os_changesType


class static_analysisType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, static=None):
        self.original_tagname_ = None
        if static is None:
            self.static = []
        else:
            self.static = static
    def factory(*args_, **kwargs_):
        if static_analysisType.subclass:
            return static_analysisType.subclass(*args_, **kwargs_)
        else:
            return static_analysisType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_static(self): return self.static
    def set_static(self, static): self.static = static
    def add_static(self, value): self.static.append(value)
    def insert_static_at(self, index, value): self.static.insert(index, value)
    def replace_static_at(self, index, value): self.static[index] = value
    def hasContent_(self):
        if (
            self.static
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='static-analysisType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='static-analysisType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='static-analysisType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='static-analysisType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='static-analysisType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for static_ in self.static:
            static_.export(outfile, level, namespace_, name_='static', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='static-analysisType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('static=[\n')
        level += 1
        for static_ in self.static:
            showIndent(outfile, level)
            outfile.write('model_.static(\n')
            static_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'static':
            obj_ = static.factory()
            obj_.build(child_)
            self.static.append(obj_)
            obj_.original_tagname_ = 'static'
# end class static_analysisType


GDSClassesMapping = {
    'dst': dstType,
    'malware-detected': malware_detectedType,
    'cnc-services': cnc_servicesType,
    'os-changes': os_changesType,
    'smtp-message': smtp_messageType,
    'interface': interfaceType,
    'static-analysis': static_analysisType,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'alerts'
        rootClass = alerts
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'alerts'
        rootClass = alerts
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    from StringIO import StringIO
    parser = None
    doc = parsexml_(StringIO(inString), parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'alerts'
        rootClass = alerts
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'alerts'
        rootClass = alerts
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from fealerts import *\n\n')
        sys.stdout.write('import fealerts as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "AsyncKeyLogger",
    "CmdLine",
    "HardwareAccessDetection",
    "OSCChangeSet",
    "alert",
    "alerts",
    "analysis",
    "apicall",
    "appexception",
    "application",
    "callstack",
    "callstack_entry",
    "cnc_service",
    "cnc_servicesType",
    "codeinjection",
    "debugcontrol",
    "dll_exports",
    "dll_loaded",
    "driver",
    "dstType",
    "end_of_report",
    "event_logger",
    "explanation",
    "exploitcode",
    "exports",
    "fid",
    "field",
    "file",
    "firefox",
    "folder",
    "heapspraying",
    "hiddenproc",
    "info",
    "interfaceType",
    "keyloggerdetected",
    "malicious_alert",
    "malware",
    "malware_detectedType",
    "mutex",
    "network",
    "os",
    "os_changesType",
    "os_inactivity_send_keys",
    "os_monitor",
    "param",
    "params",
    "process",
    "process_packed",
    "processinfo",
    "processstats",
    "regkey",
    "smtp_messageType",
    "source",
    "spooler_dll_injection",
    "src",
    "static",
    "static_analysisType",
    "stolen_data",
    "systemshutdown",
    "target",
    "uac"
]
